<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.5.3"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Collisions</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for Collision functions and variables"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="collisions,collision functions"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/place_empty.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_grid_draw.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Collisions"><span>Collisions</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>碰撞</h1><p>在规划运动或决定某些动作时，查看游戏世界中某些位置是否与其他对象发生碰撞通常很重要，并且通常为工作选择正确的碰撞函数是最重要的任务。<span data-keyref="GameMaker Name">GameMaker</span> 具有许多内置函数，可以帮助您根据项目的需要正确处理碰撞。</p><h2>如何检查碰撞</h2><h3>与物体碰撞</h3><p>检查对象碰撞的最简单方法是使用 <span class="inline3_func"><a href="place_meeting.htm">place_meeting</a></span>。</p><p class="code_heading">步骤事件</p><p class="code">if (!place_meeting(x + 4, y, obj_rock))<br>{<br>&nbsp;&nbsp; &nbsp;x += 4;<br>}</p><p>这仅检查与 <span class="inline2">obj_rock</span> 实例的碰撞。如果 <span class="inline2">x + 4</span> 处没有岩石，它会更改 X 位置以将实例移动到那里。</p><h3>与多个物体的碰撞</h3><p>您可以通过两种方式检查多个对象的碰撞：</p><ul class="colour"><li>为这些对象分配一个 <a href="../../../../The_Asset_Editors/Object_Properties/Parent_Objects.htm">父对象</a> ，并检查该单父对象</li><li>或者，传递一个包含您要检查的对象的 <a href="../../../GML_Overview/Arrays.htm">数组</a></li></ul><p>使用传递数组的第二种方法，您的代码将如下所示：</p><p class="code">if (!place_meeting(x + 4, y, [obj_rock, obj_bush]))<br>{<br>&nbsp;&nbsp; &nbsp;x += 4;<br>}</p><p>这会检查同一函数调用中 <span class="inline2">obj_rock</span> 和 <span class="inline2">obj_bush</span> 实例的冲突。</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_tip.hts"><span class="tip">提示</span></span> 建议使用父级方法进行多次冲突检查，因为您可以在多个函数调用中使用相同的父级，而无需跟踪数组。</p><p><span class="inline3_func"><a href="place_meeting.htm">place_meeting</a></span> 函数仅返回 <span class="inline2">true</span> 或 <span class="inline2">false</span>。如果您需要访问在碰撞中找到的实例，请使用 <span class="inline3_func"><a href="../../Asset_Management/Instances/instance_place.htm">instance_place</a></span>，它会返回实例句柄。</p><h3>与平铺地图的碰撞</h3><p>除了对象之外，您还可以将 <span data-keyref="Type_ID_Element_Tilemap"><a target="_blank" href="../../Asset_Management/Rooms/Tile_Map_Layers/layer_tilemap_get_id.htm">Tile Map Element ID</a></span> 传递给碰撞函数。这将检查与该图块地图的碰撞。</p><p>使用 <span class="inline3_func"><a href="../../Asset_Management/Rooms/Tile_Map_Layers/layer_tilemap_get_id.htm">layer_tilemap_get_id</a></span> 获取图层的图块地图 ID，然后将该 ID 传递给碰撞函数。</p><p class="code_heading">Create Event</p><p class="code">tilemap = layer_tilemap_get_id("TileLayer");</p><p class="code_heading">步骤事件</p><p class="code">if (!place_meeting(x + 4, y, tilemap))<br>{<br>&nbsp;&nbsp; &nbsp;x += 4;<br>}</p><p>将数组传递给碰撞函数时，您可以组合对象和图块贴图。</p><p>记住：</p><ul class="colour"><li>使用用于图块集的精灵的碰撞遮罩来检查图块地图的碰撞，可以在 <a href="../../../../The_Asset_Editors/Sprites.htm">精灵编辑器</a> 中修改该碰撞遮罩。</li><li>如果发现与 ID 为 0 的图块地图发生碰撞，类似 <span class="inline3_func"><a href="../../Asset_Management/Instances/instance_place.htm">instance_place</a></span> 或 <span class="inline3_func"><a href="collision_circle.htm">collision_circle</a></span>( 以及其他等效函数) 的函数可能会返回 0。这意味着您不应使用作为布尔条件的返回值。相反，请检查返回值是否不是 <span class="inline2">noone</span>，这意味着发现了冲突。</li><li>需要在图块集的 <strong>编辑器</strong> 中取消选中 "<a href="../../../../The_Asset_Editors/Tile_Sets.htm">禁用源精灵导出</a>"，图块碰撞才能发挥作用。</li></ul><h2 id="h">边界框</h2><p>某些实例将使用矩形边界框来检查碰撞 (除非选择了不同的遮罩形状)。</p><p>These bounding boxes use an inclusive system, i.e. they include the bottom-most and right-most edges. This means that the bounding box for a&nbsp;16x16&nbsp;collision mask is generated from <span class="inline2">(0.0, 0.0)</span>&nbsp;to <span class="inline2">(16.0, 16.0)</span> (relative to the instance).</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You can get these values using the&nbsp;<span class="inline2"><a href="../../Asset_Management/Sprites/Sprite_Instance_Variables/bbox_left.htm">bbox_left</a></span>,&nbsp;<span class="inline2"><a href="../../Asset_Management/Sprites/Sprite_Instance_Variables/bbox_top.htm">bbox_top</a></span>, <span class="inline2"><a href="../../Asset_Management/Sprites/Sprite_Instance_Variables/bbox_right.htm">bbox_right</a></span>&nbsp;and&nbsp;<span class="inline2"><a href="../../Asset_Management/Sprites/Sprite_Instance_Variables/bbox_bottom.htm">bbox_bottom</a></span> variables.</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;Since the bounding box is inclusive (as explained above), it will always extend 1 pixel beyond its bottom-right corner compared to the sprite's bounding box. For example, a 16x16 square sprite's <a href="../../Asset_Management/Sprites/Sprite_Information/sprite_get_bbox_right.htm">right edge offset</a> will be <span class="inline2">15.0</span> (the 16th pixel when starting from 0), however an instance using this sprite will give you a <span class="inline2"><a href="../../Asset_Management/Sprites/Sprite_Instance_Variables/bbox_right.htm">bbox_right</a></span> of 16 (+ its X position).</p><p>为了使两个实例发生碰撞，它们的边界框必须重叠。在像素级别，当该像素的中心被覆盖时，就会计算重叠。</p><p>For example, if you're trying to collide with a bounding box covering the area from&nbsp;<span class="inline2">(0.0, 0.0)</span>&nbsp;to <span class="inline2">(16.0, 16.0)</span>, the edge of your mask has to touch the area between&nbsp;&nbsp;<span class="inline2">(0.5, 0.5)</span>&nbsp;and&nbsp;<span class="inline2">(15.5, 15.5)</span>&nbsp;for a collision to be counted.</p><p>The functions&nbsp;<span class="inline3_func"><a href="collision_point.htm">collision_point</a></span>&nbsp;and&nbsp;<span class="inline3_func"><a href="collision_line.htm">collision_line</a></span>&nbsp;are exceptions, where they don't have to cover the pixel centre but can be checked anywhere inside the pixel. In the above example, a point check at <span class="inline2">(15.99, 15.99)</span> would return <span class="inline2">true</span>, but <span class="inline2">(16.0, 16.0)</span> would not.</p><h2><label for="one">简单的碰撞检查</label></h2><p>以下函数处理各种方法，通过这些方法可以使实例检查是否与另一个实例发生碰撞：</p><ul class="colour"><li><a href="place_empty.htm">place_empty</a></li><li><a href="place_free.htm">place_free</a></li><li><a href="place_meeting.htm">place_meeting</a></li><li><a href="position_empty.htm">position_empty</a></li><li><a href="position_meeting.htm">position_meeting</a></li><li><a href="position_change.htm">position_change</a></li><li><a href="position_destroy.htm">position_destroy</a></li><li><a href="../../Asset_Management/Instances/instance_place.htm">instance_place</a></li><li><a href="../../Asset_Management/Instances/instance_place_list.htm">instance_place_list</a></li><li><a href="../../Asset_Management/Instances/instance_position.htm">instance_position</a></li><li><a href="../../Asset_Management/Instances/instance_position_list.htm">instance_position_list</a></li></ul><h2>高级碰撞检查</h2><p>为此，可以使用以下函数 (以及与 <a href="../Movement/Movement.htm"><b>移动</b></a> 和 <a href="../../Asset_Management/Instances/Instances.htm"><b>实例</b></a> 相关的部分中详细介绍的其他函数)。这些碰撞函数的工作方式都略有不同，但它们保留了三个共同的参数，我们将在这里进行解释：</p><ul class="colour"><li><b>obj</b>:这是指定函数必须检查是否与其碰撞的对象的位置。它可以是实例ID、对象类型或特殊的Gm关键字<b>all</b>。另请注意，如果选择的对象类型是其他对象的指定<b>父对象</b>，则该对象的所有<i>子对象</i>也将包括在此检查中。<b></b></li><li><b>prec</b>:这可以是<span class="inline">true</span>或<span class="inline">false</span>，并且与碰撞检查的精度有关。如果设置为<span class="inline">true</span>，则要计算精确的碰撞(但前提是要检查的对象在其遮罩属性中具有为其碰撞检测标记的"精度")，这对于Cpu来说是一个稍微复杂的任务，因此应谨慎使用。如果<span class="inline">为假</span>，则将根据要检查的对象的边界框计算碰撞。<b></b></li><li><b>注意</b>:您可能需要检查与运行代码的对象具有相同索引的对象是否碰撞，以防止代码发现与自身碰撞，您可以将此设置为<span class="inline">true</span>。如果您正在专门查找运行代码的对象的实例，或者这并不重要，则可以将其保留为<span class="inline">false</span>。</li></ul><p>基本函数将返回发现有碰撞的实例的Id，或者在没有碰撞时返回特殊关键字<span class="inline">noone</span>，而<i>列表</i>函数将返回碰撞的实例数，并用它们的Id填充预制的D列表。请注意，如果与给定对象的这些函数和实例定义的区域存在多个碰撞，则仅返回<i>一个</i>实例Id，并且它可以是碰撞<i>中的任何一个实例。</i></p><p>存在以下处理高级碰撞的函数。</p><ul class="colour"><li><a href="collision_circle.htm">collision_circle</a></li><li><a href="collision_circle_list.htm">collision_circle_list</a></li><li><a href="collision_ellipse.htm">collision_ellipse</a></li><li><a href="collision_ellipse_list.htm">collision_ellipse_list</a></li><li><a href="collision_line.htm">collision_line</a></li><li><a href="collision_line_list.htm">collision_line_list</a></li><li><a href="collision_point.htm">collision_point</a></li><li><a href="collision_point_list.htm">collision_point_list</a></li><li><a href="collision_rectangle.htm">collision_rectangle</a></li><li><a href="collision_rectangle_list.htm">collision_rectangle_list</a></li></ul><h2>不带遮罩的碰撞检查</h2><p>以上所有函数都与碰撞检查<i>实例</i>相关，因此依赖于为该实例定义的碰撞遮罩。但是，有许多时刻需要检查与点或区域的"碰撞"，尤其是当您的实例没有指定精灵时，或者当您正在使用鼠标等时...因此<span data-keyref="GameMaker Name">GameMaker</span>还提供以下函数来帮助您解决这些问题：</p><ul class="colour"><li><a href="point_in_rectangle.htm">point_in_rectangle</a></li><li><a href="point_in_triangle.htm">point_in_triangle</a></li><li><a href="point_in_circle.htm">point_in_circle</a></li><li><a href="rectangle_in_rectangle.htm">rectangle_in_rectangle</a></li><li><a href="rectangle_in_triangle.htm">rectangle_in_triangle</a></li><li><a href="rectangle_in_circle.htm">rectangle_in_circle</a></li></ul><h2>物理碰撞</h2><p>使用内置物理时，不能保证上述碰撞函数适用于启用物理的实例。这主要是由于这些实例不再使用大多数常规内置变量(相反，启用了物理的实例具有自己的<a href="../../Physics/Physics_Variables/Physics_Variables.htm">组变量</a>)，也不使用碰撞遮罩或边界框，因为它们改用了<a href="../../Physics/Fixtures/Fixtures.htm">设备</a>。但是，有一个特殊函数可用于在启用了物理函数的情况下测试碰撞，该函数可检查重叠的设备：</p><ul class="colour"><li><a href="../../Physics/physics_test_overlap.htm">physics_test_overlap</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Movement_And_Collisions.htm">运动与碰撞</a></div><div style="float:right">Next: <a href="../Movement/Movement.htm">运动</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>