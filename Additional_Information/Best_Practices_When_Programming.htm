<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "..";
    gCommonRootRelPath = "..";
    gTopicId = "7.0_1";
  
//]]></script>

  <script type="text/javascript" src="../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Best Practices When Programming</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css">
  <script src="../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Mark Alexander">
  <meta name="topic-comment" content="Page that explains some best practices when programming using GameMaker">
  <meta name="rh-index-keywords" content="Best Practices When Programming">
  <meta name="search-keywords" content="best practices">
<meta name="brsnext" value="Additional_Information/The_File_System.htm"><meta name="brsprev" value="Additional_Information/Additional_Information.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Best Practices When Programming">
        <span>Best Practices When Programming</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>编程时的最佳实践</h1>
  <p>在本页中，我们将介绍游戏编程时的一些"最佳实践"，同时解释一下<span data-keyref="GameMaker Name">GameMaker</span>的内部工作原理。然而，在继续之前，值得注意的是两个非常重要的要点：</p>
  <ul class="colour">
    <li>这是一个<em>指南</em>，而不是100%完美的编写游戏的方法！这里提到的东西通常更多的是组织和微观优化规模，当你对GML感到舒适并认为它们是合适的时，应该将其纳入你的编程习惯。</li>
    <li>如果你的游戏运行得很好，你对它的现状很满意，那么<em>不要急于改变一切，只是为了挤出一些额外的FPS</em>。你必须在可读性、灵活性和模块化代码与改变东西所需的时间和精力以及最终的整体收益之间取得平衡。基本上，如果它没有被打破，别修改它把你在这里学到的东西留到下一个项目。</li>
  </ul>
  <p>说到这里，让我们继续前进，看看一些编写好的GML代码的一般技巧，你可以随时应用。</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">编程风格</span><span data-close-text="true">编程风格</span></a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">在编写代码时，每个人都有一个<em>风格</em>。你编程时使用的风格是你放置括号的方式，你如何标记行，以及你如何声明和命名变量等，并且对于使你的代码清晰易读是必不可少的(当你不得不在其他事情上花费一段时间后回到这个项目时，对你未来的自己来说)。</p>
    <p class="dropspot">有很多很多<a href="http://en.wikipedia.org/wiki/Programming_style">编程风格</a>，有些人会争辩说他们的风格是最好的，但事实是，只要你在使用它时保持<strong>一致</strong>，并且一切都是<em>清晰</em>和<em>明显</em>的，几乎任何风格都是好的。</p>
    <p class="dropspot"><img alt="Code Style Example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Style_Example.png">上图是一个脚本中函数声明的例子，用来说明以上几点。你可以看到它使用了JSDoc风格的注释来清楚地解释它的全部功能，并且编码风格是一致的，有4个空格缩进，下划线用于本地变量，日志输出等...</p>
    <p class="dropspot">还要注意的是，虽然脚本编辑器允许你在每个开/闭括号处折叠代码，但你可以使用<span class="inline">#region</span>和<span class="inline">#endregion</span>标记来分割代码的一部分，并大大增强可读性，特别是在处理包含多个函数的大型脚本时。区域也可以注释-请参阅手册中本页的编辑部分)：</p>
    <p class="dropspot"><img alt="Example Of Using Regions" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Regions.png">在编写代码时，您应该注意，在编译最终游戏时，<span data-keyref="GameMaker Name">GameMaker</span>会删除注释，删除不必要的换行符和空格，替换常量/宏/枚举值，这意味着你可以根据需要在代码周围添加尽可能多的空格，而不必担心保持注释简短或只使用它们有节制地</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">使用局部变量</span><span data-close-text="true">使用局部变量</span></a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">从上面关于编程风格的观点继续，很多初学者做的一件事就是尽可能多地塞进一行代码中。例如：</p>
    <p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p>
    <p class="dropspot">虽然不是完全不可读，但它是低效的(例如，<span class="inline">point_direction()</span>函数被调用了两次)，而且看起来很混乱和笨拙。它会更好地表达为：</p>
    <p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br>
      var local_x = x + lengthdir_x(100, p_dir);<br>
      var local_y = y + lengthdir_y(100, p_dir);<br>
      draw_sprite(sprite_index, image_index, local_x, local_y);</p>
    <p class="dropspot">创建这些局部变量所需的内存和资源可以忽略不计，而且你(或任何其他阅读代码的人)从它的清晰度中获得的即时好处远远超过了它。同样的想法也应该应用于函数，你应该为输入变量分配合理的名称，并在需要的地方使用清晰的格式和局部变量，以使其尽可能可读。</p>
    <p class="dropspot">局部变量在游戏中处理速度很快，所以要充分利用它们，如果一个表达式在代码块或脚本中出现两次或更多次，考虑为它创建一个局部变量。当使用<a class="tooltip" title="这是一个特殊的编译器，用于创建使用本机代码而不是解释性代码和运行程序的可执行程序包（由GameMaker VM编译使用）。编译后的代码运行速度更快，但是编译可执行文件需要更多时间。">YoYo编译器(YYC)</a>目标时，如果引用<span class="inline">global</span>如果函数或代码块中多次出现局部变量或实例变量，则在代码开始时将它们赋给局部变量，然后引用该局部变量，因为这将提供给予更好的性能。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">数组</span><span data-close-text="true">数组</span></a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">数组</a>使用速度快，需要的内存比数据结构少，但它们还可以进一步优化。当你创建一个数组时，内存是根据它的大小分配给它的，所以你应该先尝试将数组初始化到它的最大大小，即使你不打算以后再填充它。例如，如果你知道你需要一个数组最多容纳100个值，你可以直接使用<a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>函数将其初始化为100个插槽：</p>
    <p class="code">array = array_create(100, 0);</p>
    <p class="dropspot">这将在一个"chunk"中为它分配内存，所有数组值都设置为默认值0，并有助于保持快速，否则每次向数组添加新值时，整个内存都必须重新分配。</p>
    <p class="note"><span class="note">注意</span>在HTML5目标上，这样的数组赋值不适用，你的数组应该从0开始初始化！你可以通过检查os_browser变量来轻松处理这个问题，例如：</p>
    <p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br>
        {<br>
        &nbsp; &nbsp; array_create(100, 0);<br>
        }<br>
        else<br>
        {<br>
        &nbsp; &nbsp; for (var i = 0; i &lt; 100; ++i;)<br>
        &nbsp; &nbsp; {<br>
        &nbsp; &nbsp; &nbsp; &nbsp; array[i] = 0;<br>
        &nbsp; &nbsp; }<br>
        }</span></p>
    <p class="dropspot">您还可以通过将变量used设置为等于0来释放与数组相关的内存。因此，要从上面的代码示例中清除数组，您只需使用用途：</p>
    <p class="code">array = 0;</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span data-open-text="true" data-skip-index="true">数据结构</span><span data-close-text="true">数据结构</span></a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">在<span data-keyref="GameMaker Name">GameMaker</span>中，<a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">数据结构</a>已经优化，比以前的GameMaker版本快得多。它们仍然需要清理当不用于释放内存时，它们仍然可能比数组慢，但易用性和处理它们包含的数据的额外功能通常会超过最小的速度差异，所以不要害怕在游戏中使用它们。</p>
    <p class="dropspot">应该注意的是，在所有数据结构中，DS Maps特别快，无论是读取还是写入，都使其成为所有类型任务的绝佳选择。</p>
    <p class="dropspot">前面我们提到了数组的<a href="../GameMaker_Language/GML_Overview/Accessors.htm">访问器</a>，但它们也可用于数据结构，这可以帮助清理代码并使其更容易阅读。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">碰撞</span><span data-close-text="true">碰撞</span></a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">GameMaker</a> 中有<span data-keyref="GameMaker Name">多种处理冲突的方法</span>，其中大多数都会带来一些额外的 CPU 开销。 <span class="inline">collision_</span> 和 <span class="inline">point_</span> 函数、<span class="inline">place_</span> 函数和 <span class="inline">instance_</span> 函数都依赖于<a class="tooltip" title="对于精灵来说，边界框是用于最初检测碰撞区域边缘的名称，它不必与它所应用的精灵大小相同。对于序列，边界框是画布中一个或多个资源占用的总空间的外缘。">边界框</a>对房间内给定类型的所有实例进行检查，并且 虽然引擎内置了一些优化来限制这些检查，但碰撞从来都不是最有效的处理方式。 如果您开始使用精确碰撞，性能也会明显变差，因为您不仅要进行边界框检查，而且还要进行逐像素检查，这确实非常慢。</p>
    <ul class="dropspotlist">
    </ul>
    <p class="dropspot">这并不是说您不应该使用这些功能，因为它们非常方便。 但是，您应该知道使用哪些以及何时使用，因为它们的工作方式都略有不同，并且速度也不同。 粗略的经验法则是，<span class="inline">place_</span> 函数比 <span class="inline">instance_</span> 函数更快，而 instance_ 函数又比 <span class="inline">collision_</span> 和 <span class="inline">point_</span> 函数更快，因此请阅读手册中的页面以了解相关信息 每种类型的功能，并确保选择最适合每种情况的功能。</p>
    <p class="dropspot">或者，考虑创建一个基于<strong>瓷砖的碰撞系统</strong>，可以使用<a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">瓷砖贴图函数</a>甚至是自定义2D数组或DS网格来创建。这些都将非常快，并有助于提高游戏的速度。但是，如果你使用的是不规则的地形或墙，以及不与网格对齐的对象，它们可能不合适。你可以找到一个关于平铺地图冲突的非常简单的教程从以下视频链接</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0">Tile Collisions In <span data-keyref="GameMaker Name">GameMaker</span></a></li>
    </ul>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#"><span data-open-text="true" data-skip-index="true">纹理交换和顶点批</span><span data-close-text="true">纹理交换和顶点批</span></a></p>
  <div class="droptext" data-targetname="drop-down5">
    <p class="dropspot">如果打开<a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>调试覆盖</strong></a>，在测试时，你会看到在屏幕顶部的括号中有两个数字。第一个是正在执行的<strong>纹理交换</strong>的数量，第二个是<strong>顶点批处理</strong>的数量。许多因素会影响这些数字，你永远不会让它们下降到(0)(0)因为发动机需要一个或两个每一步，但你的目标应该是让这些值尽可能低。</p>
    <p class="dropspot"><img alt="The Debug Overlay Bar" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractices_DebugOverlay.png">对于纹理交换，最好、最有效的方法是优化精灵和背景在纹理页面上的存储方式。 这是通过<a href="../The_Asset_Editors/Sprites.htm">精灵属性</a>完成的，您可以在<a href="../Settings/Texture_Groups.htm">纹理组编辑器</a>中创建纹理页面。 如果您有许多仅在主菜单中使用的图像（例如），请将它们放在单独的<a href="../Settings/Texture_Information/Texture_Pages.htm">纹理页面</a>上。 如果您有特定于关卡的图像，或者玩家和敌人等，情况也是如此。基本上，您希望按用途对它们进行分组，以便尽可能减少交换。 此外，为了帮助保持 <a class="tooltip" title="VRAM是视频可用的内存量，即：可以存储纹理和图像的内存空间。">VRAM</a> 优化，您可以使用不同的<a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">预取和刷新</a>函数根据需要从内存中加载和删除纹理。</p>
    <p class="note"><span class="note">注意</span>如本页开头所述，如果您的游戏在FPS良好的情况下运行良好，则无需过多担心纹理交换.特别是在桌面目标上创建项目时。这些优化最适合用于大型游戏或低端移动的设备，如果使用不当，它们实际上会对性能产生负面影响。</p>
    <p class="dropspot">顶点信息被"批量"发送到GPU进行绘制，通常批量越大越好。因此在绘制时应避免"破坏"批量，因为这会增加发送到GPU的顶点批量的数量。有很多事情会破坏批量，主要是<strong>混合模式</strong>，更改<strong>着色器</strong>，在绘制之前改变着色器的均匀性，以及使用内置的形状和图元进行绘制。</p>
    <p class="dropspot">因此，如果你有许多使用<span class="inline">bm_add</span>混合模式绘制的子弹实例-例如-你将为每一个创建一个新的顶点批处理，这绝对是一件坏事！相反，在你的游戏中有一个控制器对象来绘制所有的子弹，像这样：</p>
    <p class="code">gpu_set_blendmode(bm_add);<br>
      <br>
      with (obj_BULLET)<br>
      {<br>
      &nbsp; &nbsp; draw_self();<br>
      }<br>
      <br>
      gpu_set_blendmode(bm_normal);
    </p>
    <p class="note"><span class="note">注意</span>这不仅仅适用于使用 <span class="inline" style="font-size: 14px">bm_add</span> - 任何混合更改都会破坏批次并影响性能。</p>
    <p class="dropspot">这样，所有的子弹都会在同一批次中被抽取。 明智地使用函数 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a>、<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a> 和 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a> 可以极大地提高性能，并且可以启用/ 尽管它们可能并不适合所有类型的图形或项目，但可以根据需要在整个项目代码中禁用。</p>
    <p class="note"><span class="note">注意</span>如果你不要求实例在使用控制器时以这种方式绘制自己，那么你可以简单地在绘制事件中添加一个注释来抑制默认的绘制，或者使实例不可见(尽管这将阻止所有绘制事件中为实例运行的所有代码)。</p>
    <p class="dropspot">另一种减少这些数量的方法是禁用子画面的<strong>分离纹理页面</strong>选项，除非绝对必要。以这种方式存储的每个图像都被发送到自己的纹理页面，并以不同的方式进行批量处理，因此，将这些图像放在常规纹理页面上会更好。然后，您可以使用<a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a>函数并将它们存储在变量中以备后用。这可能是一小部分额外的代码，但你将得到的提升是值得的。注意，这个方法不允许纹理重复！</p>
    <p class="dropspot">正如所有这些提示，如果它使你的生活更难改变它，你的游戏运行良好，不要太担心它。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#"><span data-open-text="true" data-skip-index="true">粒子</span><span data-close-text="true">粒子</span></a></p>
  <div class="droptext" data-targetname="drop-down6">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">粒子</a>提供了一种非常快速有效的方法来在游戏中创建动态效果，通常它们可以提供给予良好的性能。但是，值得注意的是，在粒子上使用加法混合，alpha混合和颜色混合可能会降低性能，特别是在移动的目标上，所以如果您不需要它，请不要使用它！特别是加法混合，可以大大增加顶点批次，应谨慎使用。</p>
    <p class="dropspot">请注意，在非WebGL HTML5目标上，具有多色，褪色的粒子将需要大量的图像缓存，并且将非常缓慢。然而，由于粒子精灵可以被动画化，因此您可以创建一个具有改变颜色的子图像的动画精灵，然后将其用于粒子。它仍然看起来像是逐渐的颜色变化，但不需要不断创建缓存图像。</p>
    <p class="dropspot">您可以从<a href="Guide_To_Using_Particles.htm">粒子使用指南</a>页了解有关粒子的更多信息。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#"><span data-open-text="true" data-skip-index="true">表面</span><span data-close-text="true">表面</span></a></p>
  <div class="droptext" data-targetname="drop-down7">
    <p class="dropspot">最后，我们将简要介绍如何使用<a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">表面</a>，因为<span data-keyref="GameMaker Name">GameMaker</span>在您的游戏中使用表面时有相当重要的优化功能：能够打开和关闭<strong>深度缓冲区</strong>。</p>
    <p class="dropspot">当你只是正常使用表面时，<span data-keyref="GameMaker Name">GameMaker</span>实际上会创建一个表面和一个附带的深度缓冲区，以确保在3D中绘制任何东西时正确的深度排序。然而，对于大多数2D游戏，这个额外的深度缓冲区是不需要的，因此占用了额外的内存空间和处理时间，可以用于其他事情。这就是函数<a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a>开始发挥作用...</p>
    <p class="dropspot">这个函数可以在你创建一个表面之前调用，以禁用深度缓冲区的生成，之后创建的所有表面将不会有为它们创建的深度缓冲区。你可以根据需要启用/禁用这个函数，甚至可以在游戏开始时调用一次，以禁用所有后续表面调用的深度缓冲区。它不会给给予很大的性能提升，但如果你的游戏严重依赖于表面，这肯定是要记住的，可能会阻止你的游戏在低规格设备上耗尽内存。</p>
  </div>
  <p>&nbsp;</p>
  <p>除了上面提到的主要内容，还有其他更一般的内容可以帮助提高性能，也被认为是"良好实践"：</p>
  <ul class="colour">
    <li>不要害怕使用三角函数，因为(与流行的观点相反)它们非常快，特别是与粒子，碰撞，弦等相比时。</li>
    <li>不要在Draw事件中放置不用于绘制的代码</li>
    <li>使用alarm来调用任何不必在每一步都调用的代码(而不是将其添加到Step事件中)</li>
  </ul>
  <p>但是，正如我们在页面开始时提到的，所有这些优化都是可选的，如果你的游戏在60个顶点批次，80个纹理交换，添加剂混合等情况下运行良好，那么不要太担心！在编写下一个游戏时记住这些事情。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="Additional_Information.htm">额外的信息</a></div>
        <div style="float:right">Next: <a href="The_File_System.htm">文件系统</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2023 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->

</body></html>