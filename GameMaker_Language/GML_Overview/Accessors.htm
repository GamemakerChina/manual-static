<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "8.2.1.2_4";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Accessors</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css">
  <script src="../../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Mark Alexander">
  <meta name="topic-comment" content="Page outlining the different Accessors">
  <meta name="rh-index-keywords" content="Accessors">
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor">
<meta name="brsnext" value="GameMaker_Language/GML_Overview/Language_Features.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Evaluation_Order.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Accessors">
        <span>Accessors</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1><span data-field="title" data-format="default">Accessors</span></h1>
  <p>GameMaker语言(GML )还允许您通过使用称为<a href="../GML_Reference/Data_Structures/Data_Structures.htm">访问器</a>的逻辑表达式来访问某些<a href="Arrays.htm">数据结构</a>和<b>数组</b>。这与您通常使用数组时的结构相似，只是在第一个参数之前使用了<em>标识符号</em>来告诉<span data-keyref="GameMaker Name">GameMaker</span>您正在使用(以前创建的)数据结构或数组文本。</p>
  <p>&nbsp;</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#"><span data-open-text="true" data-skip-index="true">DS Lists [| ]</span><span data-close-text="true">DS Lists [| ]</span> 列表</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS lists</a> (数据结构列表) 语法为：</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">因此，当你使用<span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Lists/ds_list_create.htm">ds_list_create</a></span>创建列表时，你将使用列表索引(你已经存储在变量中)来引用它，<span class="inline2">index</span>值是列表中要设置或添加的位置。例如，下面的代码创建一个列表，然后添加10个条目，将每个条目设置为从0到9的随机数：</p>
    <p class="code">ds = ds_list_create();<br>
      var index = 0;<br>
      repeat(10)<br>
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;ds[| index++] = irandom(9);<br>
      }</p>
    <p class="dropspot">请注意，如果您使用表达式向已经有值的索引添加引用，则先前的值将被替换，而不是向列表中添加进一步的索引。要添加更多的条目，您需要知道DS列表的大小并将它们添加到末尾。同样值得注意的是，你可以设置一个列表索引，它比被引用的列表的大小<i>大</i>，这将设置该值，同时扩展列表并将列表中的所有位置初始化为0。</p>
    <p class="dropspot">创建列表结构并使用数据填充后，要从列表中获取值，可能需要类似以下内容：</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">上面的代码将从位置5(第六个索引，因为列表从0开始)获取值并将其存储在变量中。如果您提供的位置超出列表大小，则将返回值<span class="inline2">undefined</span>，您可以使用函数<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm#h">is_undefined</a></span>检查。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#"><span data-open-text="true" data-skip-index="true">DS Maps [? ]</span><span data-close-text="true">DS Maps [? ]</span> 映射</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS Maps</a>的访问器是<span class="inline2">?<a id="?">，语法为：</a></span></p>
    <p class="code">map_index[? key]</p>
    <div data-conref="../../assets/snippets/Note_Tip_Map_Key_Can_Be_Any.hts">
  <p class="note"><span data-conref="../../assets/snippets/Tag_tip.hts"><span class="tip">提示</span></span>键不限于字符串，可以是任何类型，包括<a href="Structs.htm#struct">struct</a>。</p>

</div>
    <p class="dropspot">使用<span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Maps/ds_map_create.htm#h">ds_map_create</a></span>创建映射后，您将使用存储在变量中的映射索引来引用它，<span class="inline2">key</span>值是要设置或获取的映射键。例如，下面的代码创建一个映射，然后使用以下语法向其中添加几个条目：</p>
    <p class="code">ds = ds_map_create();<br>
      ds[? "Name"] = "Hamish";<br>
      ds[? "Company"] = "MacSeweeny Games";<br>
      ds[? "Game"] = "Catch The Haggis";</p>
    <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>如果映射已经包含与您尝试添加的键值相同的键值，则不会使用新值创建重复的键值，而是会替换先前的值。</p>
    <p class="dropspot">创建地图结构并使用数据填充之后，要从特定的映射键获取值，可能会出现以下情况：</p>
    <p class="code">value = ds[? "Name"];</p>
    <p class="dropspot">上面的代码将从键<span class="inline2">"Name"</span>中获取值并将其存储在变量中，但要注意，如果给定的键在DS映射中不存在，则返回的值将是<span class="inline2">undefined</span>。这可以使用函数<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm#h">is_undefined</a></span>进行检查。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#"><span data-open-text="true" data-skip-index="true">DS Grids [# ]</span><span data-close-text="true">DS Grids [# ]</span> 网格</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm#h">DS网格</a>的语法为：</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">使用<span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Grids/ds_grid_create.htm">ds_grid_create</a></span>函数创建网格后，您将使用存储在变量中的网格索引来引用它，<span class="inline2">xpos</span>和<span class="inline2">ypos</span>是网格中的位置，以获取或设置值。例如，下面的代码创建一个网格，将其清除为0，然后向其中添加几个条目：</p>
    <p class="code">ds = ds_grid_create();<br>
      ds_grid_clear(ds, 0);<br>
      var gw = ds_grid_width(ds) - 1;<br>
      var gh = ds_grid_height(ds) - 1;<br>
      repeat(10)<br>
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;var xx = irandom(gw);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;var yy = irandom(gh);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (ds[# xx, yy] == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds[# xx, yy] = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="dropspot">创建网格结构并使用数据填充之后，要从特定网格位置获取值，可能需要类似以下内容：</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">上面的代码将根据鼠标位置从给定的DS网格中获取值(除以房间中的"单元格"宽度以获得正确的位置)。如果您提供的位置在网格边界之外，则将返回值<span class="inline2">undefined</span>，您可以使用函数<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm">is_undefined</a></span>检查。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#"><span data-open-text="true" data-skip-index="true">Arrays [@ ]</span><span data-close-text="true">Arrays [@ ]</span> 数组</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">此访问器仅在启用<a href="../../Settings/Game_Options.htm">写时复制选项</a>时使用。</p>
    <p class="dropspot">数组也有自己的访问器，其工作方式与上面列出的数据结构的访问器类似。然而，数组访问器有一个有趣的属性，那就是允许你从<a href="Script_Functions.htm">脚本函数</a>或<a href="Method_Variables.htm">方法</a>中修改一个数组，而不需要复制它。当你把一个数组传递到一个函数中时，它是<strong>通过引用</strong>传递的，这意味着数组本身并没有被赋予到脚本中，而只是被引用来获取数据。通常情况下，如果你需要改变这个数组，它将被<em>复制</em>到脚本中，然后你需要将复制的数组传回(返回)，以更新原始数组。这可能会产生昂贵的处理开销，所以你可以使用访问器来代替，因为这将直接改变原始数组<em></em>，而不需要复制它。你可以在下面的例子中看到这是如何工作的。</p>
    <p class="dropspot">使用<span class="inline2">@</span>访问器的数组的语法为：</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">在实例中创建数组后，可以通过引用将其传递给脚本，然后使用访问器<span class="inline">@</span>直接更改它。例如，您可以创建数组并调用如下函数：</p>
    <p class="code">array[99] = 0;<br>
      array_populate(array);</p>
    <p class="dropspot">函数本身具有如下内容：</p>
    <p class="code">function array_populate(_array)<br>
      {<br>
      &nbsp; &nbsp; var a = _array; var i = 0; repeat(25)<br>
      &nbsp; &nbsp; {<br>
      &nbsp; &nbsp; &nbsp; &nbsp; i = irandom(99);<br>
      &nbsp; &nbsp; &nbsp; &nbsp; while (a[i] != 0)<br>
      &nbsp; &nbsp; &nbsp; &nbsp; {<br>
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = irandom(99);<br>
      &nbsp; &nbsp; &nbsp; &nbsp; }<br>
      &nbsp; &nbsp; &nbsp; &nbsp; a[@ i] = 100;<br>
      &nbsp; &nbsp; }<br>
      }</p>
    <p class="dropspot">该函数所做的就是在数组中选择25个随机位置，并将所选数组位置的值设置为100。</p>
    <p class="dropspot">当然，如果禁用了<span class="inline">"写入时复制"</span>，则不需要<strong>@</strong>访问器。</p>
    <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>在脚本函数中使用<span class="inline">参数[n]</span>数组时，不能使用数组访问器<span class="inline">@</span>。</p>
    <p class="dropspot">&nbsp;</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#"><span data-open-text="true" data-skip-index="true">Structs [$ ]</span><span data-close-text="true">Structs [$ ]</span> 结构</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>结构访问器使用<span class="inline2"><a id="$"></a>$</span>符号作为标识符号。这使得<a href="Structs.htm">结构</a>的访问器语法为：</span></p>
    <p class="code">struct[$ "name"]</p>
    <p class="dropspot">此访问器实质上是函数<span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a>和<a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>的包装程序，您可以使用它，就像DS map的访问器一样。例如，如果您创建了一个结构，并希望从名为"my_health"的变量中检索一个值，则可以执行以下操作：</span></p>
    <p class="code">var _hp = struct[$ "my_health"];</p>
    <p class="dropspot">如您所见，您并没有提供变量本身，而是提供了一个带有变量名称的<em>字符串</em>。</p>
    <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>&nbsp;如果结构没有具有给定名称的变量，则访问器将返回 <span class="inline2">undefined</span> 作为值。</p>
    <div data-conref="../../assets/snippets/Note_tip_use_nullish_with_accessors.hts">
  <p class="note"><span data-conref="../../assets/snippets/Tag_tip.hts"><span class="tip">提示</span></span>&nbsp;如果访问器返回的值是(或可能是)&nbsp;<span class="inline2">undefined</span>&nbsp;，您可能希望提供要使用的"默认"值。要做到这一点，一种简单快捷的方法是<a href="Expressions_And_Operators.htm#nullish">空值</a>运算符。</p>

</div>
    <p class="dropspot">要在结构中设置一个变量，你需要做以下工作</p>
    <p class="code">struct[$ "my_score"] = 100;</p>
    <p class="dropspot">与获取值一样，提供要设置为字符串的变量的名称，并将其设置为给定的值。如果结构中不存在使用的变量名称，则将创建该变量名称并将其设置为给定值。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p>&nbsp;</p>
  <p>访问器的一个重要特征是它们可以被<i>链接在一起</i>。这意味着，如果您具有多个嵌套数据结构和/或数组，则不再需要使用各种函数来访问嵌套结构中的深层值。例如，假设您有一个数组，并且数组中的每个项目都是DS list，如下所示：</p>
  <p class="code">array = array_create(3);<br>
    for (var i = 0; i &lt; 3; ++i;)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;array[i] = ds_list_create();<br>
    &nbsp;&nbsp;&nbsp;&nbsp;switch(i)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Wall) ds_list_add(array[i], id);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Door) ds_list_add(array[i], id);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2:<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Chest) ds_list_add(array[i], id);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
  </p>
  <p>在上面的代码中，我们已经创建了一个3项数组，并为每个数组分配了一个DS list，然后我们用游戏中各种对象的实例ID填充了不同的列表。现在，为了访问其中一个列表中的ID，我们可以做以下工作。</p>
  <p class="code">var _list = array[0];<br>
    var _id = ds_list_find_value(_list, 0);</p>
  <p>但是，你可以用更简洁的方式使用链式访问器做同样的事情，使用更少的代码：</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>您可以通过这种方式将多个访问器链接在一起，它们可以是多种类型的，以访问存储在嵌套结构每个部分中的信息。以下是更多示例：</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br>
    var _a = data[? "lists"][| 0][# 0, 0];<br>
    <br>
    // Access an array nested in a list from a script and modify it:<br>
    data[| 0][@ 10] = 100;<br>
    <br>
    // Access a map nested in a grid nested in a list nested in an array:<br>
    data[0][| 10][# 3, 4][? "key"] = "hello world";
  </p>
  <p>对事物使用链接访问器不仅意味着您可以编写更紧凑的代码，还允许您使用迭代(例如，使用<a href="Language_Features/for.htm"><span class="inline">for</span></a>循环)和其他技术以更干净、更直观的方式访问数据。</p>
  <p>值得注意的是，当以这种方式使用访问器时，您应该始终对数组使用<span class="inline2">@</span>访问器，否则您将为正在执行的任何操作添加额外的开销。如上所述，默认情况下，数组通过引用传递到函数中，然后在修改时使用"写时复制"行为。但是，如果数组是链的一部分，则链中的前一项将使用复制的数组进行更新，并且"原始"项将被删除。例如，做这样的事情：</p>
  <p class="code">// In an object event<br>
    data[| 0][0] = 100;<br>
    <br>
    // In a function<br>
    data[| 0][0] = 200;
  </p>
  <p>获得与以下操作相同的结果：</p>
  <p class="code">// In an object event<br>
    data[| 0][0] = 100;<br>
    <br>
    // In a function<br>
    data[| 0][@ 0] = 200;
  </p>
  <p>但是，第二个示例更好，因为它没有先复制整个数组的不必要开销。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div>
        <div style="float:right">Next:&nbsp;<a href="Language_Features.htm">语言特点</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2023 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->

</body></html>