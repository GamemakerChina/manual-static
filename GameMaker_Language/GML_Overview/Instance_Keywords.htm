<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.2_2"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Instance Keywords</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;"><meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all"><meta name="search-keywords" content="self,all,noone,other,instance keywords"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Evaluation_Order.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Commenting_Code.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Instance Keywords"><span>Instance Keywords</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">实例关键字</span></h1><p>为了简化<span data-keyref="GameMaker Name">GameMaker</span>中的某些操作，您可以在代码中使用多个<b>实例关键字</b>之一(无论是<span data-keyref="GML_Code">GML Code</span>还是<span data-keyref="GML_Visual">GML Visual</span>)。这些关键字用于标识实例和结构。下面的文字中对每一项进行了解释。</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>给定的关键字在内部由<strong>负整数值</strong>表示，因此在针对这些关键字或使用这些关键字分配或检查变量值时必须小心，因为稍后您可能会得到意外的结果，因为<span data-keyref="GameMaker Name">GameMaker</span>将您使用的值解释为其他值。您还应该注意，<b>完全不建议</b>在代码中直接使用整数值而不是关键字，并且可能会在以后引起问题。</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#self"><span data-open-text="true" data-skip-index="true"><span class="inline">self</span></span><span data-close-text="true"><span class="inline">self</span></span> 自身</a></p><div class="droptext" data-targetname="drop-down"><table><colgroup><col><col></colgroup><tbody><tr><th>关键字</th><th>描述</th></tr><tr><td><span class="inline">self</span></td><td>This keyword refers to the <strong>current scope</strong>, which is the instance or struct that is executing the current block of code.</td></tr></tbody></table><p class="dropspot"><span class="inline2">self</span>可用于标识当前代码块中范围内的当前结构或实例。例如：</p><p class="code">var val = 100;<br>with (instance_create_layer(x, y, "Instances", obj_Fire))<br>{<br>&nbsp; &nbsp; self.val = val;<br>}</p><p class="dropspot">在此示例中，您可以看到我们有一个名为 <i>val</i> 的 <span class="inline2">本地</span> 变量，我们希望它在新创建的对象实例中设置同名的 <i>instance</i> 变量。为了正确识别实例变量并告诉 <span data-keyref="GameMaker Name">GameMaker</span> 在调用代码块的实例中设置它，我们使用 <span class="inline2">self</span> 关键字。在大多数情况下，您还可以使用 <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/id.htm">id</a></span> 内置实例变量来代替 <span class="inline2">self</span>，但 <span class="inline2">self</span> 具有一定的优势。首先，编译器使用 <span class="inline2">self</span> 识别实例 (或结构) 比使用 <span class="inline2">id</span> 更快，因为 <span class="inline2">id</span> 值会遍历实例查找表，而 <span class="inline2">self</span> 才不是。其次，对于那些进行扩展的人来说，确保变量的正确作用域非常有用，因为使用扩展的项目可能具有全局作用域变量或与扩展中的变量同名的变量。</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span><span class="inline2">self</span> 关键字 <strong>不是</strong> 实例或结构的实际 ID 值的快捷方式，只能在上述上下文中使用。如果您需要实例的 ID <strong>值</strong> ，则需要使用 <span class="inline2">self.id</span>，例如：</p><p class="code">var myID = id;<br>with (all)<br>{<br>&nbsp; &nbsp; if (self.id == myID)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; // do something<br>&nbsp; &nbsp; }<br>}</p><p class="dropspot"><span class="inline2">self</span>与<a href="Structs.htm">structs</a>的使用方式相同，用于引用结构体的成员变量。它还可以在构造函数中使用来引用从构造函数生成的结构。</p><p class="dropspot">You can also assign <span class="inline2">self</span> as a value to a variable. What <span class="inline2">self</span> references is only determined when you use it to look up a variable. For example:&nbsp;</p><p class="code_heading">创建事件</p><p class="code">my_val = 5;<br>the_thing = self;<br><br>the_struct =&nbsp;<br>{<br>&nbsp; &nbsp; a: 4,<br>&nbsp; &nbsp; b: 5<br>}<br><br>with(the_struct)<br>{<br>&nbsp; &nbsp; a = other.the_thing.my_val;<br>}<br><br>show_debug_message(the_struct);&nbsp; //&nbsp;{ a : 5, b : 5 }</p><p class="dropspot">当创建对象的实例时执行此代码。该实例接收分配了值<span class="inline2">5</span>的变量<span class="inline2">my_val</span>和分配了值<span class="inline2">self</span>的变量<span class="inline2">the_thing</span>。它还接收变量<span class="inline2">the_struct</span>，其中变量<span class="inline2">a</span>设置为<span class="inline2">4</span>，<span class="inline2">b</span>设置为<span class="inline2">5</span>。接下来，使用<span class="inline2"><a href="Language_Features/with.htm">with</a></span>语句将范围更改为结构体的范围。在大括号<span class="inline2">{ }</span>之间，范围是结构体的范围。然后执行以下代码行：</p><p class="code">a = other.the_thing.my_val;</p><p class="dropspot">The variable <span class="inline2">a</span> is an existing variable of <span class="inline2">the_struct</span>&nbsp;so it can be assigned to directly inside the <span class="inline2">with</span>. What the expression on the right-hand side refers to can be found by checking the dot operators one by one.&nbsp;<span class="inline2">other</span>&nbsp;refers to the scope that came before, i.e. before entering the <span class="inline2">with</span> statement, so the instance scope. The instance's <span class="inline2">the_thing</span>&nbsp;variable stores the value&nbsp;<span class="inline2">self</span>, which refers to the <strong>current</strong> scope, which was just found to be that of the instance. Its&nbsp;<span class="inline2">my_val</span>&nbsp;variable stores the value <span class="inline2">5</span>, which is finally assigned to the struct's variable <span class="inline2">a</span>. The final value of <span class="inline2">the_struct</span> is therefore <span class="inline2">{a : 5, b : 5}</span>.</p><p class="dropspot">Note that doing:&nbsp;</p><p class="code">with(the_struct)<br>{<br>&nbsp; &nbsp; a = the_thing.my_val;<br>}</p><p class="dropspot">会引发错误，因为此处是在<span class="inline2">the_struct</span>的"self"上查找<span class="inline2">my_val</span>。但是，<span class="inline2">the_struct</span>没有<span class="inline2">my_val</span>变量！</p><p class="dropspot">&nbsp;</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">other</span></span><span data-close-text="true"><span class="inline">other</span></span> 另一个</a></p><div class="droptext" data-targetname="drop-down1"><table><colgroup><col><col></colgroup><tbody><tr><th>关键字</th><th>描述</th></tr><tr><td><span class="inline">other</span></td><td>This keyword refers to the "other" instance involved in a collision event, or to the instance or struct that's executing a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span>&nbsp;statement<font face="menlo, consolas, monospace"><span style="font-size:17px"><b></b></span></font> or calls a function.<br>More generally,&nbsp;<span class="inline2">other</span>&nbsp;always refers to the<strong>&nbsp;scope through which the current scope was accessed</strong>&nbsp;or, put differently, the scope you were previously in&nbsp;or the scope where you came from.</td></tr></tbody></table><p class="dropspot">特殊关键字<span class="inline2">other</span>有多种方式用于引用特定实例或结构：它可以在<span class="inline2"><a href="Language_Features/with.htm">with</a></span>语句、<a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">碰撞事件</a>中使用，或在一个函数中。本节将解释最后两个用例。</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>如果您没有处于碰撞事件中并且不使用点符号<span class="inline2">.</span>或<span class="inline2"><a href="Language_Features/with.htm">with</a></span>语句更改范围，则<span class="inline2">其他</span>仅指当前作用域，即它与<span class="inline2">self</span>指的是同一事物。</p><h2 class="dropspot">碰撞事件</h2><p class="dropspot">碰撞事件只能发生在<strong>两个</strong>实例之间。<i>可以</i>在多个实例之间有多个碰撞，但<span data-keyref="GameMaker Name">GameMaker</span>会以1对1的方式解决这些冲突，具有冲突事件的"self"实例和与其冲突的"other"实例。</p><p class="dropspot">想象一下，你有一个玩家实例，多个敌人实例和多个子弹实例，敌人可以向你开火。您可以为每个敌人指定一个项目符号实例，但在创建时会随机指定不同的损坏变量，例如：</p><p class="code">var bullet;<br>bullet = instance_create_layer(x, y, "Bullets", obj_Bullet);<br>bullet.damage = 5 + irandom(5);<br>bullet.speed = 8;<br>bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p><p class="dropspot">您可以看到我们如何使用点符号设置其变量，如<a href="Addressing_Variables_In_Other_Instances.htm">其他实例中的寻址变量</a>一节所述。这将为每个项目符号实例提供不同的损坏值，但玩家如何检测它在被子弹击中时必须承受的损坏？</p><p class="dropspot">为此，玩家需要与<span class="inline2">obj_Bullet</span>发生碰撞事件，并在该事件中使用<span class="inline2">other</span>从碰撞项目符号实例读取变量：</p><p class="code">hp -= other.damage;<br>if (hp &lt;= 0) instance_destroy();</p><p class="dropspot">上述代码将从玩家的 <i>hp</i> 变量中扣除 <span class="inline2">other</span> 实例的 <span class="inline2">damage</span> 变量中存储的金额，然后检查 <span class="inline2">hp</span> 是否低于或等于为 0。如果是，那么它将销毁玩家实例。请注意，另一个实例必须检查该变量，否则将引发错误。</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span> 碰撞事件是唯一对 <span class="inline2">other</span> 关键字具有特殊含义的事件。在所有其他事件和脚本中，<span class="inline2">other</span> 的行为将由其使用的上下文 (例如 <span class="inline2">with()</span> 块、函数、结构声明等) 定义。</p><p class="dropspot">您可以在碰撞事件中使用<span class="inline2">其他</span>为变量指定值，甚至创建新值，如下所示：</p><p class="code">// add ten to the other instance's "mana" variable<br>other.mana += 10;<br>// set the other instance variable "hit" to true, creating the variable if it doesn't already exist<br>other.hit = true;</p><h2 class="dropspot">结构声明</h2><p class="dropspot">结构体声明内的作用域不会更改，因此<span class="inline2">other</span>引用与<span class="inline2">self</span>相同的作用域(<strong>当前</strong>作用域)，即初始化该结构体的结构体或实例：</p><p class="code">var _struct =<br>{<br>&nbsp; &nbsp; parent_instance : other<br>}<br><br>show_debug_message(_struct.parent_instance == self);<br>// This prints '1' (true) meaning that both sides refer to the same instance</p><p class="dropspot">但是，您不需要使用<span class="inline2">other</span>从实例中读取变量，因为您直接引用的任何变量都将从该实例的作用域中读取，如手册<a href="Structs.htm#inst_in_struct">本节</a>中所述。只有当您希望存储对该实例的结构的引用时，才需要使用此方法。</p><h2 class="dropspot">实例方法</h2><p class="dropspot">在另一个实例的<span class="inline2">方法</span>中使用<a href="Method_Variables.htm">other</a>会引用调用该方法的实例。</p><p class="dropspot">例如，假设<span class="inline2">Object2</span>有一个引用<span class="inline2">self</span>和<span class="inline2">other</span>的方法。然后在<span class="inline2">Object1</span>中调用该方法。由于方法是在<span class="inline2">Object2</span>中创建的，所以它与<strong>绑定</strong>&nbsp;并始终使用<span class="inline2">Object2</span>&nbsp;实例作为“self”，无论哪个实例调用它。在这种情况下，调用实例变成&nbsp;<span class="inline2">other</span>。</p><p class="code">//&nbsp;In Object2<br>my_method = function()<br>{<br>&nbsp; &nbsp; show_debug_message(object_get_name(self.object_index));<br>&nbsp; &nbsp; show_debug_message(object_get_name(other.object_index));<br>}<br><br>// In Object1<br>Object2.my_method();</p><p class="dropspot">这将导致实例首先打印自己的对象名(" Object 2")，然后打印调用实例的对象名(" Object 1")。</p><p class="dropspot">这同样适用于绑定到结构的方法。</p><h2 class="dropspot">构造函数</h2><p class="dropspot">在构造函数中使用时，<span class="inline2">other</span>将引用调用该函数的实例或结构，但不建议将其用于一般用途，因为构造函数需要使用的任何外部数据都应作为参数传入。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">all</span></span><span data-close-text="true"><span class="inline">all</span></span> 全部</a></p><div class="droptext" data-targetname="drop-down2"><table><colgroup><col><col></colgroup><tbody><tr><th>关键字</th><th>描述</th></tr><tr><td><span class="inline">all</span></td><td>All instances currently active in the room.</td></tr></tbody></table><p class="dropspot">该关键字用于告诉 <span data-keyref="GameMaker Name">GameMaker</span> 要应用某个函数，或者检查房间内的所有活动实例 (不会检查或访问停用的实例)。您 <b>不能</b> 使用 <span class="inline2">all</span> 来使用 point 方法访问或设置其他实例中的变量 (请参阅 <a href="Addressing_Variables_In_Other_Instances.htm">此处</a> )，但您 <strong>可以</strong> 在使用 <span class="inline2"><a href="Language_Features/with.htm">with</a></span> 时使用它， 例如：</p><p class="code">with (all)<br>{<br>&nbsp; &nbsp; speed = 0;<br>}</p><p class="dropspot">上述代码将房间中所有实例的速度设置为0。您还可以在函数内使用<span class="inline2">all</span>来锁定或检查房间中的所有实例，例如：</p><p class="code">// Check a point for any active instance in the room<br>inst = instance_position(mouse_x, mouse_y, all);<br><br>// Check all instances for a collision along a line<br>if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}<br><br>// Add all instances in the room into a motion planning grid<br>mp_grid_add_instances(grid, all, false);</p><p class="dropspot"><span class="inline2">all</span>是一个非常有用的关键字，可以在代码和操作中的许多情况下使用，通常会减少需要编写的代码量以达到所需的效果。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">noone</span></span><span data-close-text="true"><span class="inline">noone</span></span> 无</a></p><div class="droptext" data-targetname="drop-down3"><table><colgroup><col><col></colgroup><tbody><tr><th>关键字</th><th>描述</th></tr><tr><td><span class="inline">noone</span></td><td>No instance at all.</td></tr></tbody></table><p class="dropspot">这可能看起来很奇怪，但很多时候，在对游戏进行编程时，您会发现需要检查在某个位置、碰撞等情况下是否没有找到实例。在这些情况下，您将使用此关键字来检查任何内容，例如这：</p><p class="code">if (instance_nearest(x, y, obj_enemy) != noone)<br>{<br>&nbsp; &nbsp; //do something as there is an enemy instance near<br>}</p><p class="dropspot">在此示例中，函数<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_nearest.htm">instance_nearest</a></span>将返回<span class="inline2" id="">noone</span>或最近找到的实例。基本上，任何时候您需要检查实例时，都可能会得到<span class="inline2" id="">noone</span>或返回一个实例。</p><p class="dropspot">这也可以与<span class="inline2"><a href="Language_Features/with.htm">with</a></span>语句结合使用：</p><p class="code">with (instance_nearest(x, y, obj_enemy))<br>{<br>&nbsp; &nbsp; //do something as there is an enemy instance near<br>}</p><p class="dropspot">If the function returns an instance, the code between the curly braces <span class="inline2">{ }</span> will run once. If the function returns <span class="inline2">noone</span>, the code won't be executed.</p><p class="dropspot">您还可以将<span class="inline2">noone</span>作为值分配给变量来存储此类函数的结果：</p><p class="code_heading">创建事件</p><p class="code">ins_last_collided_with = noone;</p><p class="code_heading">碰撞事件</p><p class="code">ins_last_collided_with = other.id;</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Evaluation_Order.htm">运算顺序</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>