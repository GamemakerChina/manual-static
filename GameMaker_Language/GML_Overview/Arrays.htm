<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.1_9"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Arrays</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining Arrays"><meta name="rh-index-keywords" content="Arrays"><meta name="search-keywords" content="Arrays"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Structs.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Functions/Static_Variables.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Arrays"><span>Arrays</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Arrays</h1><p>数组非常有用，是制作游戏的重要组成部分。它本质上是一种变量类型，可以将多个值保存为"列表"——考虑以下代码：</p><p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br><br>fruits = [ "Apples", "Oranges", "Mangoes" ];</p><p>我们使用<span class="inline2">[item, item, item]</span>语法创建一个存储在变量中的数组。稍后可以使用整数通过该变量访问存储在数组中的项目，从<span class="inline">0</span>开始，该整数位于<span class="inline2">[]</span>括号内：</p><p class="code">first_fruit = fruits[ 0 ];<br>second_fruit = fruits[ 1 ];<br>// ...and so on.</p><p><label for="aone">基本数组被归类为具有 1 个<strong>维度</strong>，但您也可以拥有多个维度的数组。以下部分介绍了这两种类型的数组：</label></p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">一维数组</span><span data-close-text="true">一维数组</span></a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">在进一步讨论之前，让我们先澄清一下数组实际上是什么以及它的结构。数组只是分配给变量的一种<a href="Data_Types.htm">数据类型</a>，它不仅可以包含一个值，还可以包含多个值。下图显示了基本数组的示意图：</p><p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png"></p><p class="dropspot">这称为<strong>1D</strong>(一维)数组，如您所见，该数组存储在变量"<span class="inline">a</span>"中并包含多个值。要访问该数组，您可以执行如下操作：</p><p class="code">var _val = a[0];<br>show_debug_message(_val);</p><p class="dropspot">上面的代码从数组"<span class="inline">a</span>"的位置 0 获取值，然后将其输出到控制台，根据上图所示数组的内容，控制台将输出 125。如果您执行以下操作：</p><p class="code">var _val = a[3];<br>show_debug_message(_val);</p><p class="dropspot">输出将显示"Hi！"。</p><p class="dropspot">正如您所看到的，您为数组指定了一个变量名称，然后在方括号<span class="inline">[]</span>中指定了一个值，其中该值是数组中要从中获取数据的位置。所以本质上，数组是一个容器，有多个槽来存储值，容器中的每个位置都有一个特定的数字来标识它，这就是我们放在<span class="inline">[]</span>中的数字。值得注意的是，数组的内容<b>始终从 0</b>开始，并且<i>决不能为负数</i><em>！</em></p><h3 class="dropspot">创建数组</h3><p class="dropspot">我们已经展示了如何检查数组中的数据，但是我们如何开始创建数组呢？首先，我们必须先对其进行<i>初始化</i>，然后才能使用它，否则<span data-keyref="GameMaker Name">GameMaker</span>将会给我们带来错误。初始化数组只是意味着我们为数组的每个槽赋予一个初始值，以准备在项目代码的其他地方使用它。记住这一点很重要，因为这意味着您必须在使用数组之前进行一定量的规划，但使用重复循环初始化数组很容易，如下所示：</p><p class="code">var i = 9;<br><br>repeat(10)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;array[i] = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;i -= 1;<br>}</p><p class="dropspot">这个简单的代码将初始化一个十槽数组(从 0 到 9)以保存 0，即：数组中的每个槽都包含值 0。您会注意到该数组已<i>向后</i>初始化，最后一个槽被初始化为首先定义值。这并非绝对必要，但却是最佳方法，因为它将在内存中保留一个与数组大小完全相同的空间，而如果您从 0<em>向上</em>初始化数组，则必须重新分配内存-为每个添加的附加值分配(因此对于十槽数组，在循环中初始化它会改变内存分配十次)。对于较小的阵列，速度差异可以忽略不计，但较大的阵列应尽可能以这种方式进行优化。</p><p class="note"><b>注意</b>：HTML5 导出是上述规则的例外，当定位时，您应该从 0 开始按连续顺序初始化数组。</p><p class="dropspot">您还可以使用 GML 函数<a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>初始化具有固定大小的数组，甚至可以创建不包含值的"空"数组，例如：</p><p class="code">my_array = [];</p><p class="dropspot">这告诉 GameMaker 变量"<span class="inline">my_array</span>"是一个数组，您可以在以后随时向其中<a href="../GML_Reference/Variable_Functions/array_push.htm">添加值</a>。但是，如果您尝试访问空数组中的值，则会收到错误。</p><p class="dropspot">如果您已经知道要放入数组中的项目，则可以在声明数组时在括号之间添加逗号分隔的值：</p><p class="code">my_array = ["Steve", 36, "ST-3V3 - Steve Street"];</p><h3 class="dropspot">数组界限</h3><p class="dropspot">您应该始终注意仅访问有效的数组位置，因为尝试访问数组外部的值也会出错。例如，这将导致项目在运行时崩溃：</p><p class="code">my_array = array_create(5, 0);<br>var _val = my_array[6];</p><p class="dropspot">该数组仅初始化为 5 个位置，但我们尝试获取位置 7 - 由于数组从 0 开始编号，<span class="inline">array[6]</span>是位置 7 - 因此游戏会生成错误并崩溃。</p><h3 class="dropspot">使用数组</h3><p class="dropspot">现在我们如何实际使用数组呢？与我们使用普通变量完全相同，如以下示例所示：</p><p class="code">// Add two array values together<br>total = array[0] + array[5];<br><br>// Check an array value<br>if array[9]&nbsp;== 10<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;// Do something<br>}<br><br>// Draw an array value<br>draw_text(32, 32, array[3]);</p><p class="dropspot">由于数组是按顺序编号的，这意味着您也可以循环遍历它们来执行额外的操作，就像我们初始化它一样：</p><p class="code">var total = 0;<br><br>for (var i = 0; i &lt; 10; ++i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;total += array[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;draw_text(32, 32 + (i * 32), array[i]);<br>}<br><br>draw_text(32, 32 + (i * 32), total);</p><p class="dropspot">上面的代码将把数组中的所有值相加，绘制每一个值，然后在最后绘制总值。</p><h3 class="dropspot">删除数组</h3><p class="dropspot">关于数组最后要提到的是，您可以简单地通过将定义数组的变量"重新分配"为单个值来删除数组。这将释放与该数组的所有位置和值关联的内存。例如：</p><p class="code">// Create an array<br>for (var i = 9; i &gt; -1; --i)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a[i] = i;<br>}<br><br>// Delete the array<br>a = -1;</p><p class="dropspot">如果数组有多个维度(见下文)，它们也将被清理，并且请注意，当您在实例中创建数组时，当实例从游戏中删除时不需要清理这些数组，因为它们将被清理。在 Destroy 或 Room End 时由<a class="tooltip" title="垃圾回收是游戏代码中的一部分，是一种自动化工具，用于在代码中不再引用某些东西（如数组和结构）时从内存中删除它们，而无需您明确删除它们。">垃圾收集器</a>自动删除。不过，如果任何数组位置包含对<em>动态</em>资产(例如粒子系统、缓冲区或数据结构)的引用，则需要在删除数组、销毁实例之前销毁这些<em></em>或者房间结束。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">多维数组</span><span data-close-text="true">多维数组</span></a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"><span style="text-align:justify">我们现在知道什么是一维数组，但在<span data-keyref="GameMaker Name">GameMaker</span>中，您可以拥有多个维度的数组，这些数组本质上的结构为数组内数组内数组...例如，以下是<strong>2D</strong>(二维)数组：</span></p><p class="code">array[0][0] = 5;</p><p class="dropspot">这本质上是告诉 GameMaker 该数组实际上是由各种一维数组组成的。这是一个扩展示例：</p><p class="code">array<strong>[0]</strong>[0] = 0;<br>array<strong>[0]</strong>[1] = 1;<br>array<strong>[0]</strong>[2] = 2;<br><br>array<strong>[1]</strong>[0] = 3;<br>array<strong>[1]</strong>[1] = 4;<br><strong></strong> array<strong>[1]</strong>[2] = 5;</p><p class="dropspot">在上面的代码中，<span class="inline">array[0]</span>保存另一个数组，<span class="inline">array[1]</span>也是如此。</p><p class="dropspot">或者，要访问二维数组，您还可以使用以下语法：</p><p class="code">array[0, 0] = 5;</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>以上语法仅适用于二维数组。</p><p class="dropspot">多维数组需要在使用前进行初始化，与单个一维数组相同，并且可以保存实数、字符串和任何其他<a href="Data_Types.htm">数据类型</a>，就像任何变量一样，使其成为任何游戏的理想选择需要以易于访问的方式存储大量数据(请记住，您可以轻松地循环遍历数组)。</p><p class="dropspot">您还可以通过嵌套一维数组在一条语句中初始化多维数组：</p><p class="code">two_dimensional_array =&nbsp;<br>[<br>&nbsp; &nbsp; ["Apple", 10, 2],<br>&nbsp; &nbsp; ["Orange", 5, 2],<br>&nbsp; &nbsp; ["Mango", 15, 4],<br>&nbsp; &nbsp; // ...and so on.<br>]</p><p class="dropspot">多维数组也不限于<em>仅</em>二维，您可以根据代码的需要为数组添加 3、4 或更多个维度，只需添加<span class="inline">[n]</span>个其他参数即可，例如：</p><p class="code">array[0][0][0] = 1;&nbsp; &nbsp; &nbsp;// A three dimensional array<br>array[0][0][0][0] = 1;&nbsp; // A four dimensional array<br>// etc...</p><p class="dropspot">还应该注意的是，数组中每个维度的长度可以不同，因此您可以将初始数组维度的长度设置为 3，但对于第一个维度中的每个槽，第二个维度条目的长度可以不同;例如：</p><p class="code">array[2][2] = "3";<br>array[2][1] = "2";<br>array[2][0] = "1";<br><br>array[1][3] = "four";<br>array[1][2] = "three";<br>array[1][1] = "two";<br>array[1][0] = "one";<br><br>array[0][1] = 2;<br>array[0][0] = 1;</p><p class="dropspot">在上述代码中，<span class="inline">array[0]</span>有 2 个槽，<span class="inline">array[1]</span>有 4 个槽，<span class="inline">array[2]</span>有 3 个槽。</p><h3 class="dropspot">扩展示例</h3><p class="dropspot">这是如何在实际游戏中使用这一点的最后一个示例：假设您想根据随机值在游戏中的四个不同点生成四个不同的敌人。好吧，我们可以使用二维数组来完成此操作，并节省编写大量代码。</p><p class="dropspot">首先，我们应该初始化我们将在"控制器"对象的 Create 事件中使用的数组(请注意使用注释来提醒您每个数组条目的作用)：</p><p class="code">enemy[3][2] = 448; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//y position<br>enemy[3][1] = 32; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//x position<br>enemy[3][0] = obj_Slime; //Object<br>enemy[2][2] = 448;<br>enemy[2][1] = 608;<br>enemy[2][0] = obj_Skeleton;<br>enemy[1][2] = 32;<br>enemy[1][1] = 608;<br>enemy[1][0] = obj_Knight;<br>enemy[0][2] = 32;<br>enemy[0][1] = 32;<br>enemy[0][0] = obj_Ogre;</p><p class="dropspot">现在，我们有了要生成实例的对象及其在房间内相应的 x 和 y 生成坐标，所有这些都存储在我们的数组中。现在可以在控制器对象的另一个事件(例如警报或按键事件)中按如下方式使用：</p><p class="code">//get a random number from 0 to 3, inclusive<br>var i = irandom(3);<br><br>//Use the array to create the object<br>instance_create_layer(enemy[i][1], enemy[i][2], "Enemy_Layer", enemy[i][0]);</p><p class="dropspot">该短代码现在将在游戏房间中生成一个随机敌人，并且它使用的代码比"<span class="inline">if / then / else</span>"结构甚至"<span class="inline">switch</span>"少得多，并且因为数组是在创建事件中一起初始化后，编辑和更改任何这些值都会变得更加容易，因为它们没有<a class="tooltip" title="在计算机编程中，术语“硬编码”用于描述被认为是固定的并且不太可能更改的代码。硬编码功能以无法稍后修改的方式内置于硬件或软件中。例如，如果您要制作游戏并将玩家的健康状况“硬编码”为10，那么您将在整个游戏代码中使用值10，而不是使用变量。">硬编码</a>到项目代码的其余部分中。</p></div><p>&nbsp;</p><p>另请参阅：<a href="../GML_Reference/Variable_Functions/Array_Functions.htm">数组函数</a><a href="../GML_Reference/Variable_Functions/Variable_Functions.htm#h"></a></p><h2>数组作为函数参数</h2><p>您可以将数组作为参数传递到<a href="Script_Functions.htm">脚本函数</a>和<a href="Method_Variables.htm">方法变量</a>中，并在函数内的任意位置修改这些数组。这样做也会修改原始数组。</p><p>例如，此函数只是更改传递给它的数组的前三个元素：</p><p class="code">modify_array = function (array)<br>{<br>&nbsp; &nbsp; array[0] = 2;<br>&nbsp; &nbsp; array[1] = 4;<br>&nbsp; &nbsp; array[2] = 6;<br>}</p><p>您现在可以创建一个数组并将其传递给此函数，该函数将修改该数组：</p><p class="code">my_array = [100, 4, 214];<br><br>modify_array(my_array);<br><br>show_debug_message(my_array); // Prints [2, 4, 6];</p><p>在以前的 GameMaker 版本中，情况并非如此，因为修改函数内的数组会创建一个副本。如果需要，仍可以启用此<em>已弃用的</em>行为：请阅读下面的"<strong>写入时复制</strong>"部分以了解更多信息。</p><h2 id="h">写时复制</h2><p>写入时复制行为已弃用，并且仅当在<strong>常规游戏选项</strong>中启用"<a href="../../Settings/Game_Options.htm">启用数组的写入时复制行为</a>"时才使用。本节描述启用此选项时阵列的行为。</p><p>如上一节所述，数组可以作为参数传递给函数。为此，您只需指定数组变量(不需要每个单独的位置，也不需要<span class="inline">[]</span>括号)，整个数组将<b>通过引用传递</b>到函数中：</p><p class="code">my_array = [1, 2, 4, 8, 16];<br><br>do_something(my_array);</p><p>不过，当启用<strong>写入时复制</strong>时，更改函数内任何数组的值都会根据您的修改创建一个临时副本。原始数组没有被修改。这种行为称为写入时复制。</p><p>要实际修改传递到函数中的原始数组，您必须将其返回，或使用<span class="inline">@</span>访问器。</p><p>例如，上面调用的函数<span class="inline2">do_something()</span>可能会执行如下简单操作：</p><p class="code">do_something = function(array)<br>{<br>&nbsp; &nbsp; array[1] = 200;<br>}</p><p>现在，您可能希望<span class="inline2">my_array</span>保存值<span class="inline2">1、200、4</span>等，这通常是正确的 - 但当启用<strong>写入时复制</strong>时，原始数组不受影响。</p><p>要解决此问题，您可以让函数<strong>返回</strong>修改后的数组副本，然后将其应用回原始变量：</p><p class="code">my_array = [1, 2, 4, 8, 16];<br><br>my_array = do_something(my_array);</p><p>该函数本身将返回修改后的数组：</p><p class="code">do_something = function(array)<br>{<br>&nbsp; &nbsp; array[1] = 200;<br><br>&nbsp; &nbsp; return array;<br>}</p><p class="note"><span class="note">注意</span><b></b>如果您不更改任何数组的值，而是引用它们，则不需要上述代码。引用数组不会复制它，并且解析速度会更快。</p><p>第二种解决方案是使用 <span class="inline">@</span> 访问器直接更改数组值，这样可以节省必须进行临时复制的 CPU 开销。这意味着您不需要从函数返回数组，可以直接编辑它：</p><p class="code">do_something = function(array)<br>{<br>&nbsp; &nbsp; array[@ 1] = 200;<br>}</p><p>使用此访问器会绕过写入时复制行为并直接修改引用的数组。这可用于有选择地禁用特定语句的写入时复制，同时保持该选项启用。</p><p>同样，如果 <strong>禁用</strong> ( 这是默认且推荐的选项 ) <strong>写入时复制</strong> ，则所有这些都是不必要的。</p><p>从以下页面了解有关访问器及其工作方式的更多信息以及数组示例：</p><ul class="colour"><li><a href="Accessors.htm">配件</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Structs.htm">结构与构造函数</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>