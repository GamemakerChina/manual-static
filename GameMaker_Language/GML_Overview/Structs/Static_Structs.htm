<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.1.2.0_1"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Static Struct</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page explaining static structs for constructor functions"><meta name="rh-index-keywords" content="Static Structs"><meta name="search-keywords" content="Static Structs, static_get, static_set, is_instanceof"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Struct_Forbidden_Variables.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Structs.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Static Struct"><span>Static Struct</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">静态结构</span></h1><p>每个函数都有一个"静态结构"，其中存储了它的静态变量。您可以使用<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_get.htm">static_get</a></span>获取该结构：</p><p class="code">function counter()<br>{<br>&nbsp;&nbsp; &nbsp;static count = 0;<br>&nbsp;&nbsp; &nbsp;return count ++;<br>}<br><br>repeat (10)&nbsp;counter();<br><br>// Get static struct of counter()<br>var _static_counter = static_get(counter);<br><br>// Both of these read the same variable<br>show_debug_message(counter.count); // 10<br>show_debug_message(_static_counter.count); // 10</p><p>对于<a href="../Structs.htm#constr">构造函数</a>也是如此。每个构造函数都有一个静态结构，其中存储了它的静态变量和静态方法。</p><p>从构造函数创建的每个结构都从该静态结构访问其静态变量。</p><div data-conref="../../../assets/snippets/Note_Warning_Static_Struct_Call_Once.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">警告</span></span>您无法从从未调用过的函数访问静态变量，因为静态变量是在第一次调用函数时初始化的。尝试这样做将会出现错误并导致游戏崩溃。</p></div><h2 id="h">静态链</h2><p>当您使用构造函数继承时，这些构造函数形成一个"静态链" -- 一个静态结构链，其中每个子级都链接到其父级。</p><p>例如，假设您有一个构造函数 <span class="inline2">item</span>，以及一个构造函数 <span class="inline2">potion</span>，它是 <span class="inline2">item</span> 的子级：</p><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>var _potion = new potion();</p><p>您可以使用 <span class="inline2">static_get(potion)</span>&nbsp;获取 <span class="inline2">potion</span> 的静态结构-这是存储 <span class="inline2">potion</span> 的静态变量的位置。让我们将其称为 <span class="inline2">static_potion</span>。</p><p>现在，如果您调用 <span class="inline2">static_get(static_potion)</span>，您将获得 <span class="inline2">item</span> 的静态结构！这与您从 <span class="inline2">static_get(item)</span> 获得的结构相同。</p><p class="code">function item () constructor {}<br>function potion () : item () constructor {}<br><br>var _potion = new potion();<br>var _static_potion = static_get(potion);<br><br>show_debug_message(static_get(item) == static_get(_static_potion)); // true (1)</p><p>这是因为 <span class="inline2">item</span> 是 <span class="inline2">potion</span> 构造函数的父级，因此 <span class="inline2">item</span> 的静态结构链接到 <span class="inline2">potion</span> 的静态结构。</p><p>顶级构造函数的静态结构(即那些没有父构造函数的静态结构)共享相同的父结构。该结构是"根"静态结构，其父结构为<span class="inline2">undefined</span>：</p><p class="code">var _static_item = static_get(item);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// the static struct of item<br>var _root = static_get(_static_item);&nbsp; &nbsp; &nbsp; &nbsp; // the static struct of all top-level static structs<br>var _must_be_undefined = static_get(_root);&nbsp; // undefined</p><p>此共享结构是<em>所有</em>结构的根父结构，并定义在结构转换为字符串时调用的默认<span class="inline3_func">toString</span>函数。</p><p>这意味着您可以获取结构的完整静态链，如下所示：</p><p class="code">static_chain = [];<br>var _node = static_get(potion);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the static struct to start at<br>while (!is_undefined(_node))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;array_push(static_chain, _node);<br>&nbsp;&nbsp; &nbsp;_node = static_get(_node);<br>};<br><br>array_foreach(static_chain, show_debug_message);&nbsp; &nbsp; &nbsp; &nbsp;// output the path to the root struct</p><h2>父级和父级中的变量名称相同子构造函数</h2><p>由于静态变量属于定义它们的构造函数，因此可以在子构造函数中定义与父构造函数的静态变量同名的静态变量。例如：</p><p class="code">function shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; static shapes = [];<br>&nbsp; &nbsp; array_push(shapes, self);<br>}<br>function rectangle () : shape () constructor<br>{<br>&nbsp; &nbsp;&nbsp;static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function square () : rectangle () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function ellipse () : shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}</p><p>现在，每个形状都有自己的<span class="inline2">count</span>静态变量，用于跟踪该形状的项目数量。子形状也会增加其父形状的<span class="inline2">计数</span>，因为它们除了运行自己的构造函数之外，还运行父形状的构造函数。</p><p class="code">s1 = new shape();&nbsp; &nbsp; &nbsp; &nbsp; // Added 1 shape<br>s2 = new rectangle();&nbsp; &nbsp; // Added 1 rectangle (and therefore also 1 shape)<br>s3 = new square();&nbsp; &nbsp; &nbsp; &nbsp;// Added 1 square (and therefore also 1 rectangle and 1 shape)<br>s4 = new ellipse();&nbsp; &nbsp; &nbsp; // Added 1 ellipse (and therefore also 1 shape)<br><br>show_debug_message($"Number of shapes: {shape.count}");&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 4<br>show_debug_message($"Number of rectangles: {rectangle.count}");&nbsp; // 2<br>show_debug_message($"Number of squares: {square.count}");&nbsp; &nbsp; &nbsp; &nbsp; // 1<br>show_debug_message($"Number of ellipses: {ellipse.count}");&nbsp; &nbsp; &nbsp; // 1</p><h2 id="h2">点运算符如何查找变量名称</h2><p>假设您正在使用点运算符(即<span class="inline2">struct.variable_name</span>)在结构体中查找特定变量。</p><p>如果该结构包含具有该名称的非静态变量，则点运算符返回该变量。如果没有，点运算符返回静态​​链中具有该名称的第一个变量，检查当前静态结构，然后根据需要遍历整个静态链，直到遇到具有该名称的变量。如果在静态链中的任何位置都找不到变量名称，<span data-keyref="GameMaker Name">GameMaker</span>将抛出错误。</p><p>例如:</p><p class="code">function root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("root");<br>&nbsp; &nbsp; }<br>}<br><br>function child() : root() constructor { }<br><br>function child_with_static_func() : root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_static_func");<br>&nbsp; &nbsp; }<br>}<br><br>function child_with_func() : root() constructor<br>{<br>&nbsp; &nbsp; show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_func");<br>&nbsp; &nbsp; }<br>}<br><br>child1 = new child();<br>child1.show();<br><br>child2 = new child_with_static_func();<br>child2.show();<br><br>child3 = new child_with_func();<br>child3.show();</p><p>上面的代码中发生了以下情况：</p><ul class="colour"><li><span class="inline2">child1</span>是一个<span class="inline2">child</span>，它没有自己的<span class="inline3_func">show()</span>方法，但继承自<span class="inline2">root</span>。调用<span class="inline3_func">root.show()</span>并输出<span class="inline2">"root"</span>。</li><li><span class="inline2">child2</span>是一个<span class="inline2">child_with_static_func</span>，它具有静态<span class="inline2">show()</span>方法。调用此方法会输出<span class="inline2">"child_with_static_func"</span>。</li><li><span class="inline2">child3</span>是一个<span class="inline2">child_with_func</span>，它继承自<span class="inline2">root</span>，但也有自己的(非静态)<span class="inline3_func">show()</span>方法。它调用自己的<span class="inline3_func">show()</span>方法，输出<span class="inline2">"child_with_func"</span>。</li></ul><h2>父级的静态变量或方法</h2><p>在某些情况下，您可能希望从子构造函数中访问父构造函数的静态变量或方法。为了实现这一点，您可以沿着静态链向上访问父级的静态变量：</p><p class="code">function parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function() { show_debug_message("Parent Innit?"); }<br>}<br><br>function child() : parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static = static_get(self);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static_parent = static_get(_static);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_static_parent.init(); // Calls the parent's init()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Child Innit!");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><h2>检查多重继承</h2><p>您可以使用 <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span> 来检查结构是否属于给定的构造函数，或者是否将该构造函数作为父构造函数。</p><p>这是通过检查结构是否在其静态链中的任何位置具有给定构造函数的静态结构来完成的。</p><div data-conref="../../../assets/snippets/is_instanceof_example.hts"><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>function enemy() constructor {}<br><br>var _potion = new potion();<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)<br>show_debug_message(is_instanceof(_potion, item)); // true (1)<br>show_debug_message(is_instanceof(_potion, enemy)); // false (0)</p><p>上面的代码显示了三个构造函数：<span class="inline2">item</span>，<span class="inline2">potion</span>，它是 <span class="inline2">item</span> 的子类，以及 <span class="inline2">enemy</span>，它是一个单独的构造函数。</p><p>它从 <span class="inline2">potion</span> 构造函数创建一个结构。使用 <span class="inline2">is_instanceof()</span>，我们可以检查新结构：</p><ul class="colour"><li>是一个 <span class="inline2">potion</span></li><li>是一个 <span class="inline2">item</span></li><li>不是一个 <span class="inline2">enemy</span></li></ul><p>通过这种方式，您可以检查结构是否"是"某物，因为 <strong>potion 是 item</strong>，因此它为两个构造函数返回 <span class="inline2">true</span>。然而，如果不是真的，反过来： <strong>item 不是 potion</strong> 。</p></div><h2 id="h1">改变静态结构</h2><p>函数 <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span> 允许您更改函数的静态结构 (构造函数或非构造函数)。通过这种方式，您可以更改构造函数及其结构可用的静态变量，还可以更改构造函数所属的 " 静态链"。</p><p>此函数的推荐用例是反序列化。如果您从 JSON 加载结构，那么这些结构将不属于任何构造函数，但是您可以通过使用 <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span> 将构造函数 " 应用 " 到一个结构，以便该结构接收其共享的静态变量，并且您可以运行 <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span> 来检查其类型。</p><div data-conref="../../../assets/snippets/static_set_example.hts"><p class="code">var _potion = json_parse(_json_string);<br><br>show_debug_message(is_instanceof(_potion, potion)); // false (0)<br><br>var _static_potion = static_get(potion);<br>static_set(_potion, _static_potion);<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)</p><p>在上面的代码中，从 JSON 字符串加载 potion 结构时，它只被创建为一个简单的结构，不属于构造函数，也没有任何静态变量。</p><p>在将 <span class="inline2">potion</span> 的静态结构应用于它之后，它将成为 <span class="inline2">potion</span> 的实例 (如用 <span class="inline2">is_instanceof()</span> 测试的那样)，并且还获得包含在 <span class="inline2">potion</span> 构造函数中的任何静态变量和静态方法。</p></div><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Structs.htm">Structs</a></div><div style="float:right">Next:&nbsp;<a href="../Struct_Forbidden_Variables.htm">结构禁止的变量</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>