<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="7.0_10"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Guide To Using Blendmodes</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page that explains how blendmodes work."><meta name="rh-index-keywords" content="blendmodes,Guide To Using Blendmodes"><meta name="search-keywords" content="blendmodes,blending,blend modes"><meta name="brsnext" value="Additional_Information/Project_Format.htm"><meta name="brsprev" value="Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Guide To Using Blendmodes"><span>Guide To Using Blendmodes</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>混合模式使用指南</h1><p>如果您使用 <span data-keyref="GameMaker Name">GameMaker</span> 已有一段时间，那么您几乎肯定会遇到过 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/GPU_Control.htm">混合模式</a> ，甚至可能会在您的游戏中使用它们。混合模式是改变某些内容的绘制方式以提供有趣且特定的图形效果的好方法，但是您知道它们如何工作以及如何使用它们吗？这是一个可能令人困惑的主题，因此在本节中，我们希望消除有关混合模式的一些神秘面纱，并使您能够在游戏中充分利用它们。</p><h2>概述</h2><p>混合模式基本上告诉你的游戏将某些东西与事先已经绘制的其他东西混合起来。您绘制到屏幕上的所有内容均由四个组成部分组成 - <strong>红色</strong> 、 <strong>绿色</strong> 、 <strong>蓝色</strong> 和 <strong>Alpha</strong>- 默认情况下，它们使用混合绘制到屏幕上模式 <span class="inline">bm_normal</span>。</p><p>此混合模式会绘制所有像素，其颜色和 Alpha 值基本保持不变 (不过，在本节后面您将看到这 <em>完全</em> 不正确 ...)，但 <span data-keyref="GameMaker Name">GameMaker</span> 有一个数字可以通过设置来改变此行为的 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">内置混合模式</a> 。</p><h2>事物是如何绘制的</h2><p>当 <span data-keyref="GameMaker Name">GameMaker</span> 开始绘制像素时，会存在一个 <strong>源颜色</strong> ( 您要绘制的像素的颜色) 和一个 <strong>目标颜色</strong> ( 我们已经存在于像素中的颜色) 重新绘制)。例如，如果您在同一像素绘制黄色后绘制粉红色，则粉红色是 <strong>源</strong> ( 您正在绘制的内容)，黄色是 <strong>目标</strong> ( 因为它是已经在那了)。</p><p>在确定像素的最终颜色时，GameMaker 会根据 <strong>混合模式</strong> 组合源颜色和目标颜色 - 基本上是在问 " 我应该如何组合粉色和黄色？"。</p><h2>计算最终颜色</h2><p>源颜色和目标颜色均包含 RGBA( <strong>红色</strong> 、 <strong>绿色</strong> 、 <strong>蓝色</strong> 和 <strong>Alpha</strong>) 分量，每个分量都是 0 到 1 之间的浮点值。</p><p>像素的最终颜色是通过将源和目标的每个分量乘以一个 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">因子</a> ，然后根据设置的 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">方程</a> 将它们组合在一起来计算的。</p><p>这意味着最终像素颜色的计算方式如下：<span class="inline2">( 源 * 因子 )+( 目标 * 因子 )</span>。</p><p>此处，两个值最终会 <strong>相加</strong> ，因为默认方程为 <span class="inline2">bm_add</span>，不过您可以更改该方程以进行减法或使用其他方程 (本页稍后介绍)。</p><h2>基本混合模式</h2><p>使用函数 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">gpu_set_blendmode</a></span> <strong>同时</strong> 应用一组混合因子和方程，作为 " 预设 " 混合模式。</p><p>您可以在 (例如) 绘制精灵之前调用此函数，然后在之后重置它，如下所示：</p><p class="code">gpu_set_blendmode(bm_add);<br>draw_self();<br>gpu_set_blendmode(bm_normal);</p><p>该代码使用 <strong>加法</strong> 混合模式绘制实例精灵。加法混合模式使用可用的 GML 常量之一进行设置，其中有六个用于基本模式：</p><div data-conref="../assets/snippets/Table_Gpu_blend_modes.hts"><table><colgroup><col><col><col><col></colgroup><tbody><tr><th colspan="4"><span data-keyref="Type_Constant_Draw_Blend_Mode"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_blendmode.htm">Blend Mode Constant</a></span></th></tr><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_normal</span></td><td>Normal blending (the default blend mode).</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_alpha</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_add</span></td><td>Additive blending. Luminosity values of light areas are added.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_subtract</span></td><td>Subtractive blending. Source is subtracted from the destination.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_subtract</span></td></tr><tr><td><span class="inline">bm_reverse_subtract</span></td><td>Reverse subtractive blending. Destination is subtracted from the source.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_reverse_subtract</span></td></tr><tr><td><span class="inline">bm_min</span></td><td>Smaller value from source and destination is selected.</td><td>(<span class="inline">bm_one</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_min</span></td></tr><tr><td><span class="inline">bm_max</span></td><td>Max blending. Similar to additive blending.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_colour</span>)</td><td><span class="inline">bm_eq_add</span></td></tr></tbody></table></div><p>"扩展混合模式 " 列显示 (分别) 应用于源和目标的因子，"混合方程 " 列显示用于将这两个值结合在一起的方程。</p><p>现在让我们看看每种基本混合模式的工作原理。</p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">注意</span></span> 这些示例演示了使用绿色背景并在其上绘制蓝色方块的混合模式，这两种模式都算作目标。使用每种混合模式绘制一个灰色方块作为源。</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down9" href="#"><span data-open-text="true" data-skip-index="true">bm_normal</span><span data-close-text="true">bm_normal</span></a></p><div class="droptext" data-targetname="drop-down9"><table class="cke_show_border"><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_normal</span></td><td>Normal blending (the default blend mode).</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_alpha</span>)</td><td><span class="inline">bm_add</span></td></tr></tbody></table><p class="dropspot"><span class="inline2">bm_normal</span> 是默认混合模式，它将源颜色与其 Alpha 相乘，并将目标颜色与源 Alpha 的 <em>逆</em> 相乘 (为源颜色留出空间)。最后将两者相加 (因为等式为 <span class="inline2">bm_add</span>)：</p><p><img alt="bm_normal example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_normal.png"></p><p class="dropspot">本示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">bm_add</span><span data-close-text="true">bm_add</span></a></p><div class="droptext" data-targetname="drop-down"><table class="cke_show_border"><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_add</span></td><td>Additive blending. Luminosity values of light areas are added.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_add</span></td></tr></tbody></table><p class="dropspot">此混合模式将源颜色与其 Alpha 相乘，就像 <span class="inline2">bm_normal</span> 一样，但它保持目标原样 (<span class="inline2">bm_one</span>)。然后将两者加在一起，产生更浅的颜色。请注意，颜色值不能超过 255( 或低于 0)，因此任何加起来超过该值的值都将被限制为 255。</p><p class="dropspot"><img alt="bm_add example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_add.png"> 此示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p><p class="dropspot">使用这种混合模式是获得 " 霓虹灯发光 " 外观的好方法，并且最常用于照明效果、激光或任何您想要发光或发光的东西。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">bm_subtract</span><span data-close-text="true">bm_subtract</span></a></p><div class="droptext" data-targetname="drop-down1"><table class="cke_show_border"><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_subtract</span></td><td>Subtractive blending. Source is subtracted from the destination.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_subtract</span></td></tr></tbody></table><p class="dropspot">此模式使用与 <span class="inline2">bm_add</span> 相同的因子，但它使用减法方程，以便从目标颜色中减去源颜色 (即从背景中移除前景)。</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_subtract.png"> 此示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p><p class="dropspot">这对于使用遮罩移除部分图像非常有用，如本页后面 " <strong>混合方程</strong> " 下的示例所示。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">bm_reverse_subtract</span><span data-close-text="true">bm_reverse_subtract</span></a></p><div class="droptext" data-targetname="drop-down2"><table class="cke_show_border"><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_reverse_subtract</span></td><td>Reverse subtractive blending. Destination is subtracted from the source.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_reverse_subtract</span></td></tr></tbody></table><p class="dropspot">这再次使用与 <span class="inline2">bm_add</span> 和 <span class="inline2">bm_subtract</span> 相同的因子，但使用逆减方程，因此从源颜色中减去目标颜色 (即从前景中移除背景)。</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_reverse_subtract.png"> 此示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-open-text="" data-rhwidget="DropSpot" data-target="drop-down6" href="#"><span data-open-text="true" data-skip-index="true">bm_min</span><span data-close-text="true">bm_min</span></a></p><div class="droptext" data-targetname="drop-down6"><table class="cke_show_border"><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_min</span></td><td>Smaller value from source and destination is selected.</td><td>(<span class="inline">bm_one</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_min</span></td></tr></tbody></table><p class="dropspot">这对源颜色和目标颜色都使用了 <span class="inline2">bm_one</span> 因子，因此它们根本不会改变。然后它利用最小方程，以便源和目标 (对于 R、G、B 和 A 中的每一个) 之间较小的分量值用于最终像素。</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_min.png"> 此示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down8" href="#"><span data-open-text="true" data-skip-index="true">bm_max</span><span data-close-text="true">bm_max</span></a></p><div class="droptext" data-targetname="drop-down8"><table><tbody><tr><th>常量</th><th>描述</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_max</span></td><td>Max blending. Similar to additive blending.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_colour</span>)</td><td><span class="inline">bm_eq_add</span></td></tr></tbody></table><p class="dropspot"><span>这种混合模式解释起来比较复杂，但它基本上是将源颜色乘以源 Alpha，然后将它们与目标颜色值乘以源颜色值的逆值相加。我们将在文章的第二部分介绍 <span class="inline2">bm_max</span>( 以及其他混合模式) 背后的实际数学原理，但您需要知道的是，结果将是更 " 饱和 " 且更明亮的颜色，而不会导致达到与使用<span></span></span> <span class="inline2">bm_add</span><span><span></span> 相同的纯白色亮度。</span></p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_max.png"> 此示例中的背景颜色为 <span class="inline2">(50, 100, 0, 255)</span>。</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>现在您已经了解了在 <span data-keyref="GameMaker Name">GameMaker</span> 中使用混合模式的基础知识。它获取源图像 (正在绘制的内容) 的 RGBA 值，然后将这些值与目标图像 (正在绘制的内容) 的 RGBA 值混合。</p><p>这种混合是通过将每个像素颜色和 Alpha 的各个分量乘以不同的量来完成的，具体取决于我们希望实现的效果，然后使用设置的方程计算两者的最终像素值。</p><p>有了这些知识，您就可以开始在游戏中使用混合模式来获得发光的激光、逼真的阴影或饱和的过渡效果，但这里还有更多东西需要学习！下面我们将了解 <strong>扩展混合模式</strong> ( 因子)，并探讨其背后的一些数学知识，以便您可以创建自己的混合效果，例如相乘或叠加。</p><h2>扩展混合模式 (因子)</h2><p>上面我们讨论了函数 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">gpu_set_blendmode</a></span>，但现在我们要看看 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">gpu_set_blendmode_ext</a></span>。</p><p>我们看到每种内置混合模式都会将 <strong>因子</strong> 应用于 <strong>源</strong> 和 <strong>目标</strong> 颜色。例如，<span class="inline2">bm_add</span> 将源与其 Alpha 相乘，并将目标与 1 相乘。</p><p>通过 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">gpu_set_blendmode_ext</a></span>，您可以分别为源颜色和目标颜色 <strong>手动设置系数</strong> 。这为您提供了更多绘制像素的选项，因为您现在可以手动选择源乘什么，然后选择目标乘什么。</p><h3>表示组件</h3><p>如您所知，源颜色和目标颜色都具有 RGBA 分量。每个分量的值都在 0 到 1 之间。</p><p>我们将源 RGBA 表示为 <span class="inline2">(Rs, Gs, Bs, As)</span>，将目标 RGBA 表示为 <span class="inline2">(Rd, Gd, Bd, Ad)</span>。</p><p>了解这些将帮助您了解每个因素的工作原理，因为一个因素可能会使用例如 <span class="inline2">Rs</span> 值 (源红色)，但另一个可能使用 <span class="inline2">Rd</span>( 目标红色)，依此类推。</p><h3>计算最终像素</h3><p>当你去画东西时，GPU 会得到以下信息：</p><ul class="colour"><li><span class="inline2">(Rs，Gs，Bs，As)</span>=您要绘制的颜色的RGB和Alpha。</li><li><span class="inline2">(Rd、Gd、Bd、Ad)</span>= 像素位置处已存在的颜色的 RGB 和 Alpha。</li></ul><p>然后它对每个像素执行以下操作：</p><p class="code">final_pixel_colour = &nbsp;(Rs,Gs,Bs,As) * source_blend_factor + (Rd,Gd,Bd,Ad) * destination_blend_factor</p><p>正如您所看到的，它将源 RGBA 和目标 RGBA 与其设定因子相乘。然后，它根据默认 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">方程</a> 将它们加在一起。</p><p>混合因子在 <span data-keyref="GameMaker Name">GameMaker</span> 中由许多 GML 常量定义。每个常量都是可用于源或目标 (或两者) 的因子。可以考虑以下因素：</p><div data-conref="../assets/snippets/Table_Gpu_blend_modes_ext.hts"><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Draw_Blend_Mode_Factor"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_blendmode_ext.htm">混合模式因子常量</a></span></th></tr><tr><th>常量</th><th>混合因子(红色、绿色、蓝色、透明度)</th></tr><tr><td><span class="inline">bm_zero</span></td><td>(0, 0, 0, 0)</td></tr><tr><td><span class="inline">bm_one</span></td><td>(1, 1, 1, 1)</td></tr><tr><td><span class="inline">bm_src_colour</span></td><td>(Rs, Gs, Bs, As)</td></tr><tr><td><span class="inline">bm_inv_src_colour</span></td><td>(1-Rs, 1-Gs, 1-Bs, 1-As)</td></tr><tr><td><span class="inline">bm_src_alpha</span></td><td>(As, As, As, As)</td></tr><tr><td><span class="inline">bm_inv_src_alpha</span></td><td>(1-As, 1-As, 1-As, 1-As)</td></tr><tr><td><span class="inline">bm_dest_alpha</span></td><td>(Ad, Ad, Ad, Ad)</td></tr><tr><td><span class="inline">bm_inv_dest_alpha</span></td><td>(1-Ad, 1-Ad, 1-Ad, 1-Ad)</td></tr><tr><td><span class="inline">bm_dest_colour</span></td><td>(Rd, Gd, Bd, Ad)</td></tr><tr><td><span class="inline">bm_inv_dest_colour</span></td><td>(1-Rd, 1-Gd, 1-Bd, 1-Ad)</td></tr><tr><td><span class="inline">bm_src_alpha_sat</span></td><td>(f, f, f, 1) where f = min(As, 1-Ad)</td></tr></tbody></table></div><p>第二列显示使用该因子时，R、G、B、A 各分量乘以的值。</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">bm_normal 工作原理示例</span> <span data-close-text="true">bm_normal 工作原理示例</span></a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot">现在我们来看看一个实际示例，了解如何将其结合起来在 <span data-keyref="GameMaker Name">GameMaker</span> 中进行绘图。为此，我们将了解 <span class="inline2">bm_normal</span> 混合模式，它很简单：</p><p class="code">gpu_set_blendmode_ext(bm_src_alpha, bm_inv_src_alpha);<br>gpu_set_blendequation(bm_add);</p><p class="dropspot">人们在使用混合模式时遇到的问题之一是可视化结果，因此为了展示其背后的数学原理，我们将使用此混合模式作为我们的测试对象，因为它是每个人使用最多的混合模式，并且我们确切地知道会发生什么从中。假设我们在颜色为 <span class="inline2">(64, 128, 255, 255)</span> 的背景上绘制一个颜色为 <span class="inline2">(128, 255, 64, 255)</span> 的矩形：</p><p class="dropspot"><img alt="Example of bm_normal" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example1.png"> 因此，我们的混合计算如下所示：</p><p class="code_plain"><strong>Colours:</strong><br>Source: (128, 255, 64, 255) = (0.5, 1, 0.25, 1)<br>Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br><br><strong>Factors:</strong><br>bm_src_alpha (As, As, As, As) = (255, 255, 255, 255) = (1, 1, 1, 1)<br>bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = &nbsp;(0, 0, 0, 0)<br><br><strong>Formula:</strong><br>(Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br><br><strong>Apply factors</strong>:<br>(0.5, 1, 0.25, 1) * (1, 1, 1, 1) + (0.25, 0.5, 1, 1) * (0, 0, 0, 0)<br><br><strong>Apply equation</strong>:<br>(0.5, 1, 0.25, 1) + (0, 0, 0, 0)<br><br><strong>Final pixel</strong>:<br>(0.5, 1, 0.25, 1) = (128, 255, 64, 255)</p><p class="dropspot">如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 <span class="inline2">(128, 255, 64, 255)</span>。</p><p class="dropspot">您可以看到包含较低的 alpha 如何影响此计算：</p><p class="code_plain"><strong>Colours:</strong><br>Source (128, 255, 64, 128) = (0.5, 1, 0.25, 0.5)<br>Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br><br><strong>Factors:</strong><br>bm_src_alpha (As, As, As, As) = (128, 128, 128, 128) = (0.5, 0.5, 0.5, 0.5)<br>bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = (0.5, 0.5, 0.5, 0.5)<br><br><strong>Formula:</strong><br>(Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br><br><strong>Apply factors</strong>:<br>(0.5, 1, 0.25, 0.5) * (0.5, 0.5, 0.5, 0.5) + (0.25, 0.5, 1, 1) * (0.5, 0.5, 0.5, 0.5)<br><br><strong>Apply equation</strong>:<br>(0.25, 0.5, 0.125, 0.25) + (0.125, 0.25, 0.5, 0.5)<br><br><strong>Final pixel</strong>:<br>(0.375, 0.75, 0.625, 0.75) = (96, 192, 159, 192)</p><p class="dropspot">这将给出最终像素颜色 <span class="inline2">(96, 192, 159, 192)</span>，并给出如下所示的图像：</p><p class="dropspot"><img alt="Example Of bm_normal With Alpha" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example2.png"></p><p class="dropspot">希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。</p></div><p>现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。</p><h2>创建您自己的混合模式</h2><p>使用不同的可用因子，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个类似于Photoshop中使用的<strong>乘</strong>效果。我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：</p><p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);</p><p>在我们实际使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：</p><p><img alt="The &quot;Multiply&quot; Blend Mode In Photoshop" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Multiply.png">使用我们的扩展混合模式，我们得到以下结果：</p><p class="code">(Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad) + (Rd, Gd, Bd, Ad) * (0,0,0,0) = (Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad)<br>Source colour * dest colour + dest colour * zero = source colour * dest colour</p><p>混合因子<span class="inline2">bm_zero</span>有效地将目标颜色从等式中移除(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此该模式的名称为"乘"。要在<span data-keyref="GameMaker Name">GameMaker</span>中使用此模式，您只需在<strong>Draw Event</strong>中设置如下内容：</p><p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);<br>draw_self();<br>gpu_set_blendmode(bm_normal);</p><p>下一张图片是使用以下代码从GameMaker的测试项目中拍摄的：</p><p><img alt="The &quot;Multiply&quot; Blend Mode In GameMaker" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_MultiplyGMS.png"> 您看得出来差别吗？可能不会！然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。</p><p>请注意，尽管并非艺术程序使用的所有混合模式都可以在 <span data-keyref="GameMaker Name">GameMaker</span> 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。</p><p>值得一提的是，通过 <span data-keyref="GameMaker Name">GameMaker</span>，您可以使用函数 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext_sepalpha.htm">gpu_set_blendmode_ext_sepalpha</a></span> 更进一步。这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。</p><h2>混合方程</h2><p>通过阅读本指南，您应该已经对什么是混合方程有了基本的了解。它控制应用因素后源颜色和目标颜色如何混合在一起。</p><p>默认情况下，源值和目标值都会 <strong>相加</strong> 在一起，因为默认方程为 <span class="inline2">bm_eq_add</span>。</p><p><span data-keyref="GameMaker Name">GameMaker</span> 中提供了以下方程，可以使用 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">gpu_set_blendequation</a></span> 设置：</p><div data-conref="../assets/snippets/Table_Gpu_blend_equations.hts"><table><colgroup><col><col><col></colgroup><tbody><tr><th colspan="3"><span data-keyref="Type_Constant_Draw_Blend_Mode_Equation"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Mode Equation Constant</a></span></th></tr><tr><th>常量</th><th>描述</th><th>方程</th></tr><tr><td><span class="inline">bm_eq_add</span></td><td>Add both together (the default equation).</td><td>source + destination</td></tr><tr><td><span class="inline">bm_eq_subtract</span></td><td>Subtract source from destination.</td><td>destination - source</td></tr><tr><td><span class="inline">bm_eq_reverse_subtract</span></td><td>Subtract destination from source.</td><td>source - destination</td></tr><tr><td><span class="inline">bm_eq_min</span></td><td>Use whichever value is smaller.</td><td>min(source, destination)</td></tr><tr><td><span class="inline">bm_eq_max</span></td><td>Use whichever value is larger.</td><td>max(source, destination)</td></tr></tbody></table><p class="note"><span data-conref="../assets/snippets/Tag_important.hts"><span class="important">重要</span></span> 当使用 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">bm_eq_min</a> 或 <span class="inline2">bm_eq_max</span> 作为混合方程时，不会应用 <span class="inline2">混合因子</span> ，这与使用 <span class="inline2">bm_one</span> 作为混合方程实际上相同的因素。</p></div><p>您还可以使用 <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation_sepalpha.htm">gpu_set_blendequation_sepalpha</a></span> 分别设置用于 RGB 和 Alpha 的方程。</p><h3>使用方程式</h3><p>您可以使用 <span class="inline2">bm_eq_subtract</span> 方程来实现以下效果：</p><p><video class="center" src="../assets/Images/Scripting_Reference/GML/Reference/Drawing/bm_eq_subtract.mp4" width="480" height="320" controls=""></video></p><p>在这里，我们将精灵绘制到 <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">表面</a> ，然后绘制一个圆圈，减去表面中的所有内容。然后将表面绘制到屏幕上。</p><p>这可以通过以下 <strong>Create</strong> 和 <strong>Draw</strong> 事件代码来实现：</p><p class="code_heading">Create Event</p><p class="code">surf = surface_create(128, 128);<br>surf_x = 175;<br>surf_y = 90;</p><p class="code_heading">Draw Event</p><p class="code">if (!surface_exists(surf))<br>{<br>&nbsp;&nbsp; &nbsp;surf = surface_create(128, 128);<br>}<br><br>// Draw to surface<br>surface_set_target(surf);<br>&nbsp;&nbsp; &nbsp;<br>draw_sprite(spr_box, 0, 0, 0);<br>&nbsp;&nbsp; &nbsp;<br>gpu_set_blendequation(bm_eq_subtract);<br>draw_circle(mouse_x - surf_x, mouse_y - surf_y, 32, 0);<br>gpu_set_blendequation(bm_add);<br>&nbsp;&nbsp; &nbsp;<br>surface_reset_target();<br>&nbsp;&nbsp; &nbsp;<br>// Draw surface to screen<br>draw_surface(surf, surf_x, surf_y);</p><p>首先，我们创建一个表面并定义其房间位置。然后在 Draw 事件中，我们检查表面是否不存在，然后重新创建它。</p><p>然后我们在该表面上绘制以下内容：</p><ul class="colour"><li>一个精灵，正常绘制。其中的一部分将被 " 删除"，以便我们可以看穿它。</li><li>使用 <span class="inline2">bm_eq_subtract</span> 方程在鼠标位置绘制的 <a href="../GameMaker_Language/GML_Reference/Drawing/Basic_Forms/draw_circle.htm">圆</a> 。</li></ul><p>圆将从表面已有的任何内容中减去其 alpha 值，使我们能够看穿它。</p><p>然后在房间中的定义位置绘制表面。</p><h2>表面 和 透明度</h2><p>关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的 <strong>Alpha</strong> 分量。 当仅绘制到<a class="tooltip" title="应用程序表面是一种特殊的内置表面，GameMaker Studio 2将在游戏的“绘制事件”中将所有内容绘制到该表面（表面实际上是为图形保留的内存区域）。然后这个表面被绘制到每个游戏帧末尾的显示缓冲区，向玩家显示它的内容。">应用程序表面</a>或<a class="tooltip" title="显示缓冲区是最终绘制所有内容的“画布”。一些事件直接针对此事件（例如Pre Draw事件），而另一些事件将首先绘制到应用程序表面，然后将其绘制到显示缓冲区。">显示缓冲区</a>时，您实际上不需要考虑目标 Alpha 值，因为它<em>始终</em>为 1。 然而，您自己制作的表面是不同的，因为您可以清除表面以使其具有您希望的从零到一的任何 alpha 值。 这会导致一些有趣的效果，与大多数人的预期相反。</p><p>为了说明这一点，我们将使用基本的默认值<span class="inline">bm_normal</span>进行绘制。大多数人认为将表面清除为alpha 0，然后绘制alpha为0.5的东西将给予结果alpha值也为0.5.<strong>但事实并非如此</strong>，许多人认为这是<span data-keyref="GameMaker Name">GameMaker</span>渲染事物的"错误"。然而，正如你所看到的，这根本不是一个bug！</p><p>假设你有一个表面，每个像素的alpha都是0，然后你用<span class="inline">bm_normal</span>混合模式在上面画一个alpha为0.5的圆。整个表面仍然是alpha 0，但是在圆中alpha实际上是0.25，因为：</p><p class="code">0.5 * 0.5 + 0 * 0.5 = 0.5 * 0.5 = 0.25</p><p>如果你在现有的圆上再画一个alpha值为0.5的圆，那么在圆外的alpha值为0，在圆间的alpha值为0.25，在较小的圆内的alpha值为0.375：</p><p class="code">0.5 * 0.5 + 0.25 * 0.5 = 0.25 + 0.125 = 0.375</p><p>如果你继续在一个alpha值为0的曲面上画一些alpha值为0.5的圆，然后把这个曲面画到房间上，你可以清楚地看到：</p><p><img alt="Surface Alpha Illustration" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Surface.png">如果您对 Alpha 仍然有点困惑，请尝试将其想象为另一种颜色。 它的行为就像一种颜色，所有关于它的计算都以类似的方式完成。 它只是不太明显，尽管它对其他颜色的影响是可见的。 这就是我们在使用曲面和混合模式（甚至是 <span class="inline">bm_normal</span>）时需要注意的最后一点...</p><p>即使表面的 Alpha 为 0， <em><strong>颜色分量仍然存在并且会影响所有混合操作</strong></em> 。因此，绘制到已使用红色 (例如) 清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能想到的不同效果。上面的图像是在清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：</p><p><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_SurfaceRed.png"> 希望您现在可以使用我们上面概述的公式并应用适当的 <span class="inline">bm_normal</span> 数字来弄清楚为什么会发生这种情况。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Additional_Information.htm">额外的信息</a></div><div style="float:right">Next:&nbsp;<a href="Guide_To_Using_JSON.htm">JSON 使用指南</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>