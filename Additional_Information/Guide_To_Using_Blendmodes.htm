<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "..";
    gCommonRootRelPath = "..";
    gTopicId = "7.0_10";
  
//]]></script>

  <script type="text/javascript" src="../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Guide To Using Blendmodes</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css">
  <script src="../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Mark Alexander">
  <meta name="topic-comment" content="Page that explains how blendmodes work.">
  <meta name="rh-index-keywords" content="blendmodes,Guide To Using Blendmodes">
  <meta name="search-keywords" content="blendmodes,blending,blend modes">
<meta name="brsnext" value="Additional_Information/Compatibility_Functions.htm"><meta name="brsprev" value="Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Guide To Using Blendmodes">
        <span>Guide To Using Blendmodes</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Blendmodes使用指南</h1>
  <p>如果您已经使用<span data-keyref="GameMaker Name">GameMaker</span>一段时间，您几乎肯定会遇到<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/GPU_Control.htm">混合模式</a>，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。</p>
  <p>&nbsp;</p>
  <h2>概述</h2>
  <p>混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式<span class="inline">bm_normal</span>绘制到屏幕上的。这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是<em>完全</em>正确.)，但<span data-keyref="GameMaker Name">GameMaker</span>有许多内置的混合模式，可以设置来改变这种行为。</p>
  <p>当<span data-keyref="GameMaker Name">GameMaker</span>去绘制一个像素时，有一个<strong>源颜色</strong>(要绘制的像素的颜色)和<strong>目标颜色</strong>(我们要绘制的像素中已有的颜色)。当确定像素的新颜色时，GameMaker将根据<strong>混合模式</strong>将源颜色和目标颜色联合收割机组合，颜色的每个分量被存储为0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子并且通过将目的地颜色的每个分量乘以某个其它因子并且然后将结果加在一起分量，成分</p>
  <p>&nbsp;</p>
  <h2>基本混合模式</h2>
  <p><span data-keyref="GameMaker Name">GameMaker</span>使用函数<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">gpu_set_blendmode()</a>来更改游戏用于绘制的混合。您可以在绘制精灵之前(例如)调用此函数，然后在绘制精灵之后再次设置它，类似于以下内容：</p>
  <p class="code">gpu_set_blendmode(bm_add);<br>
    draw_self();<br>
    gpu_set_blendmode(bm_normal);</p>
  <p>该代码使用<strong>添加</strong>混合模式绘制实例精灵。添加混合模式使用可用的GML常量之一设置，其中有四个用于基本模式：</p>
  <p class="code">bm_normal<br>
    bm_add<br>
    bm_subtract<br>
    bm_max</p>
  <p>我们已经看到了<span class="inline">bm_normal</span>的外观-因为这是所有默认设置！-所以让我们继续更详细地查看其他三个.</p>
  <p><img alt="bm_normal example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes1_BmNormal.png"></p>
  <p>&nbsp;</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">bm_add</span><span data-close-text="true">bm_add</span></a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果背景图像是RGB值为(100，15，70)，然后绘制一个RGB为(120，25，30)，然后(使用bm_add)矩形的每个像素的最终RGB值将为(220，40，100).注意颜色值不能超过255(或小于0)，所以任何加起来超过255的值都将被箝位到255。</p>
    <p class="dropspot"><img alt="bm_add example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes1_BmAdd.png">使用此混合模式是获得"氖发光"外观的好方法，并且最常用于照明效果，或激光或任何您想要看起来发光或发光的东西。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">bm_subtract</span><span data-close-text="true">bm_subtract</span></a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">这个混合模式与前一个有点不同，因为它是基于百分比而不是直接值。这个百分比是从目标颜色(正在绘制的像素的颜色)中减去的百分比。为了更好地解释这一点，让我们看一个例子。</p>
    <p class="dropspot"><img alt="bm_subtract example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes1_BmSubtract.png">假设你想将房间某个区域中所有像素的红色值减少25%。你首先需要得到255的25%，然后将其转换为RGB颜色值，最后使用沿着bm_subtract在该区域上绘制。类似这样：</p>
    <p class="code">var red = (25 / 100) * 255;<br>
      var col = make_colour_rgb(red, 0, 0);<br>
      gpu_set_blendmode(bm_subtract);<br>
      draw_rectangle_colour(0, 0, 128, 256, col, col, col, col, false);<br>
      gpu_set_blendmode(bm_normal);</p>
    <p class="dropspot">按照同样的规则，如果你想简单地将背景的亮度降低50%，那么你就会有一个50%红色，50%绿色和50%蓝色的颜色，即：RGB(128，128，128)。这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">bm_max</span><span data-close-text="true">bm_max</span></a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">这种混合模式更难解释，但它基本上是将源颜色乘以源alpha，然后将它们添加到目标颜色值乘以逆源颜色值。bm_max背后的实际数学(以及其他混合模式)我们将在文章的第二部分介绍，但您需要知道的是，结果将是一个更"饱和"和更明亮的颜色，而不会导致使用<span class="inline">BM_add</span>将导致的相同的纯白色亮度。</p>
    <p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes1_BmMax.png">当你需要绘制重叠的图像时，此混合模式非常有用，而不会让它们变得太亮而看不见。明亮的部分会变得更亮，但它们仍然应该保持一定的颜色和色调。请注意，使用此混合模式时，源图像的alpha值也会影响最终效果。</p>
  </div>
  <p>&nbsp;</p>
  <p>现在你知道了在GameMaker中使用混合模式的基本原理，它为源图像获取RGB和alpha值(正在绘制的内容)，然后将其与目标的RGB和alpha值混合(也正在绘制)。这种混合是通过将每个像素颜色和alpha的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们来看看<span data-keyref="GameMaker Name">扩展混合模式</span>，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。</p>
  <p>&nbsp;</p>
  <h2>扩展混合模式</h2>
  <p>上面我们已经讨论了函数 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm"><span class="inline">gpu_set_blendmode（）</span></a>，但现在我们将看看 <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm"><span class="inline">gpu_set_blendmode_ext（）</span></a>。顾名思义，这是一个用于设置 <em>custom </em>blend 模式的扩展函数，但这是如何工作的呢？在我们进一步讨论之前，让我们先看一下枯燥的技术答案：</p>
  <ul class="colour">
    <li>函数 <span class="inline">gpu_set_blendmode_ext</span><span class="inline">（src， dest）</span> 指示用于源颜色和目标颜色的混合模式。新颜色是某个因素乘以来源，另一个因素乘以目的地。这些因素是用这个函数设置的。为了理解这一点，源和目标都具有红色、绿色、蓝色和 alpha 分量。所以 <strong>source </strong>is （<span class="inline">Rs， Gs， Bs， As</span>） 和 <strong>destination </strong>is （<span class="inline">Rd， Gd， Bd， Ad</span>）。所有值都被认为介于 0 和 1 之间。</li>
  </ul>
  <p>现在，虽然文本是正确的，并解释了混合模式的作用，但它并不直观......所以让我们更详细地解释一下这是怎么回事。</p>
  <p>当我们谈论<strong>source</strong>时，我们谈论的是正在绘制的像素的颜色和alpha值，而当我们谈论<strong>destination</strong>时，我们谈论的是正在绘制的像素的颜色和alpha值。为了使事情更容易，我们可以将源颜色写为它的组件，如下所示：</p>
  <ul class="colour">
    <li><span class="inline">(Rs，Gs，Bs，As)</span>=您要绘制的颜色的RGB和Alpha。</li>
  </ul>
  <p>目的地应该是这样的：</p>
  <ul class="colour">
    <li><span class="inline">(Rd，Gd，Bd，Ad)</span>=您要绘制的颜色的RGB和Alpha。</li>
  </ul>
  <p>所以当我们在屏幕上画东西时，我们的图形处理器实际上对每个像素都做了以下操作：</p>
  <p class="code">final_pixel_colour = &nbsp;(Rs,Gs,Bs,As) * source_blend_factor + (Rd,Gd,Bd,Ad) * destination_blend_factor</p>
  <p>上述<strong>混合因子</strong>在<span data-keyref="GameMaker Name">GameMaker</span>中由多个GML常量定义，每个常量代表源或目标R、G、B和A值应乘以的因子。可用因子包括：</p>
  <ul class="colour">
    <li><span class="inline">bm_zero</span>: Blend factor is (0, 0, 0, 0)</li>
    <li><span class="inline">bm_one</span>: Blend factor is (1, 1, 1, 1)</li>
    <li><span class="inline">bm_src_colour</span>: Blend factor is (Rs, Gs, Bs, As)</li>
    <li><span class="inline">bm_inv_src_colour</span>: Blend factor is (1-Rs, 1-Gs, 1-Bs, 1-As)</li>
    <li><span class="inline">bm_src_alpha</span>: Blend factor is (As, As, As, As)</li>
    <li><span class="inline">bm_inv_src_alpha</span>: Blend factor is (1-As, 1-As, 1-As, 1-As)</li>
    <li><span class="inline">bm_dest_alpha</span>: Blend factor is (Ad, Ad, Ad, Ad)</li>
    <li><span class="inline">bm_inv_dest_alpha</span>: Blend factor is (1-Ad, 1-Ad, 1-Ad, 1-Ad)</li>
    <li><span class="inline">bm_dest_colour</span>: Blend factor is (Rd, Gd, Bd, Ad)</li>
    <li><span class="inline">bm_inv_dest_colour</span>: Blend factor is (1-Rd, 1-Gd, 1-Bd, 1-Ad)</li>
    <li><span class="inline">bm_src_alpha_sat</span>: Blend factor is (f, f, f, 1); f = min(As, 1-Ad)</li>
  </ul>
  <p><span data-keyref="GameMaker Name">GameMaker</span>拥有的四种"基本"混合模式实际上是其中两种混合因子的组合。</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">bm_normal 工作原理示例 </span><span data-close-text="true">bm_normal 工作原理示例 </span></a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">是时候看看一个实际的例子了，它是如何在<span data-keyref="GameMaker Name">GameMaker</span>中进行绘图的。为此，我们将看看bm_normal，它实际上是：</p>
    <p class="code">gpu_set_blendmode_ext(bm_src_alpha, bm_inv_src_alpha);</p>
    <p class="dropspot">人们使用混合模式的一个问题是可视化结果，所以为了展示它们背后的数学原理，我们将使用这种混合模式作为我们的测试主题，因为它是每个人使用最多的混合模式，我们确切地知道它会带来什么。(128，255，64，255)的颜色的背景上：</p>
    <p class="dropspot"><img alt="Example of bm_normal" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example1.png">因此，我们的混合模式如下所示：</p>
    <p class="code">Source: (128, 255, 64, 255) = (0.5, 1, 0.25, 1)<br>
      Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br>
      bm_src_alpha (As, As, As, As) = (255, 255, 255, 255) = (1, 1, 1, 1)<br>
      bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = &nbsp;(0, 0, 0, 0)<br>
      (Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br>
      (0.5, 1, 0.25, 1) * (1, 1, 1, 1) + (0.25, 0.5, 1, 1) * (0, 0, 0, 0)<br>
      (0.5, 1, 0.25, 1) + (0, 0, 0, 0) = (0.5, 1, 0.25, 1) = (128, 255, 64, 255)</p>
    <p class="dropspot">如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 <strong>(128, 255, 64, 255)</strong>。 您还可以看到 alpha 的包含如何影响该值：</p>
    <p class="code">Source (128, 255, 64, 128) = (0.5, 1, 0.25, 0.5)<br>
      Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br>
      bm_src_alpha (As, As, As, As) = (128, 128, 128, 128) = (0.5, 0.5, 0.5, 0.5)<br>
      bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = (0.5, 0.5, 0.5, 0.5)<br>
      (Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br>
      (0.5, 1, 0.25, 0.5) * (0.5, 0.5, 0.5, 0.5) + (0.25, 0.5, 1, 1) * (0.5, 0.5, 0.5, 0.5)<br>
      (0.25, 0.5, 0.125, 0.25) + (0.125, 0.25, 0.5, 0.5) = (0.375, 0.75, 0.625, 0.75) = (96, 192, 159, 192)</p>
    <p class="dropspot">这给出了最终的像素颜色（96、192、159、192），并将给出如下所示的图像：</p>
    <p class="dropspot"><img alt="Example Of bm_normal With Alpha" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example2.png"></p>
    <p class="dropspot">希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。 现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。</p>
    <p class="dropspot">&nbsp;</p>
    <p class="dropspot">&nbsp;</p>
  </div>
  <p>现在你知道了如何设置混合模式的工作原理，并看到了一个例子，它被用于日常绘图，让我们看看一些更复杂的东西。</p>
  <p>&nbsp;</p>
  <h2>创建您自己的混合模式</h2>
  <p>使用不同的可用因子，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个类似于Photoshop中使用的<strong>乘</strong>效果。我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：</p>
  <p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);</p>
  <p>在我们实际使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：</p>
  <p><img alt="The &quot;Multiply&quot; Blend Mode In Photoshop" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Multiply.png">使用我们的扩展混合模式，我们得到以下结果：</p>
  <p class="code">(Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad) + (Rd, Gd, Bd, Ad) * (0,0,0,0) = (Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad)<br>
    Source colour * dest colour + dest colour * zero = source colour * dest colour</p>
  <p>混合因子<span class="inline">bm_zero</span>有效地将目标颜色从等式中移除(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此该模式的名称为"乘"。要在<span data-keyref="GameMaker Name">GameMaker</span>中使用此模式，您只需在<strong>Draw Event</strong>中设置如下内容：</p>
  <p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);<br>
    draw_self();<br>
    gpu_set_blendmode(bm_normal);</p>
  <p>下一张图片是使用以下代码从GameMaker的测试项目中拍摄的：</p>
  <p><img alt="The &quot;Multiply&quot; Blend Mode In GameMaker" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_MultiplyGMS.png">您看得出来差别吗？ 可能不会！ 然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。 请注意，尽管并非艺术程序使用的所有混合模式都可以在 <span data-keyref="GameMaker Name">GameMaker</span> 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着 这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。</p>
  <p>值得一提的是，通过 <span data-keyref="GameMaker Name">GameMaker</span>，您可以使用函数 <span class="inline"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext_sepalpha.htm">gpu_set_blendmode_ext_sepalpha()</a></span> 更进一步。 这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。 我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。</p>
  <p>&nbsp;</p>
  <h2>曲面和阿尔法</h2>
  <p>关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的 <strong>Alpha</strong> 分量。 当仅绘制到<a class="tooltip" title="应用程序表面是一种特殊的内置表面，GameMaker Studio 2将在游戏的“绘制事件”中将所有内容绘制到该表面（表面实际上是为图形保留的内存区域）。然后这个表面被绘制到每个游戏帧末尾的显示缓冲区，向玩家显示它的内容。">应用程序表面</a>或<a class="tooltip" title="显示缓冲区是最终绘制所有内容的“画布”。一些事件直接针对此事件（例如Pre Draw事件），而另一些事件将首先绘制到应用程序表面，然后将其绘制到显示缓冲区。">显示缓冲区</a>时，您实际上不需要考虑目标 Alpha 值，因为它<em>始终</em>为 1。 然而，您自己制作的表面是不同的，因为您可以清除表面以使其具有您希望的从零到一的任何 alpha 值。 这会导致一些有趣的效果，与大多数人的预期相反。</p>
  <p>为了说明这一点，我们将使用基本的默认值<span class="inline">bm_normal</span>进行绘制。大多数人认为将表面清除为alpha 0，然后绘制alpha为0.5的东西将给予结果alpha值也为0.5.<strong>但事实并非如此</strong>，许多人认为这是<span data-keyref="GameMaker Name">GameMaker</span>渲染事物的"错误"。然而，正如你所看到的，这根本不是一个bug！</p>
  <p>假设你有一个表面，每个像素的alpha都是0，然后你用<span class="inline">bm_normal</span>混合模式在上面画一个alpha为0.5的圆。整个表面仍然是alpha 0，但是在圆中alpha实际上是0.25，因为：</p>
  <p class="code">0.5 * 0.5 + 0 * 0.5 = 0.5 * 0.5 = 0.25</p>
  <p>如果你在现有的圆上再画一个alpha值为0.5的圆，那么在圆外的alpha值为0，在圆间的alpha值为0.25，在较小的圆内的alpha值为0.375：</p>
  <p class="code">0.5 * 0.5 + 0.25 * 0.5 = 0.25 + 0.125 = 0.375</p>
  <p>如果你继续在一个alpha值为0的曲面上画一些alpha值为0.5的圆，然后把这个曲面画到房间上，你可以清楚地看到：</p>
  <p><img alt="Surface Alpha Illustration" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Surface.png">如果您对 Alpha 仍然有点困惑，请尝试将其想象为另一种颜色。 它的行为就像一种颜色，所有关于它的计算都以类似的方式完成。 它只是不太明显，尽管它对其他颜色的影响是可见的。 这就是我们在使用曲面和混合模式（甚至是 <span class="inline">bm_normal</span>）时需要注意的最后一点...</p>
  <p>即使表面的 Alpha 为 0，<em><strong>颜色分量仍然存在并且会影响所有混合操作</strong></em>。 因此，绘制到已使用红色（例如）清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能认为的不同效果。 上面的图像是在黑色背景上清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：</p>
  <p><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_SurfaceRed.png">希望您现在可以使用我上面概述的公式并应用 <span class="inline">bm_normal</span> 的适当数字来弄清楚为什么会发生这种情况。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="Additional_Information.htm">额外的信息</a></div>
        <div style="float:right">Next:&nbsp;<a href="Project_Format.htm">项目格式</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2023 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Blendmodes
Blending
Blend Modes
-->
  <!-- TAGS
using_blendmodes
-->

</body></html>