<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../../../..";
    gCommonRootRelPath = "../../../..";
    gTopicId = "8.2.2.5.2";
  
//]]></script>

  <script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Motion Planning</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css">
  <script src="../../../../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Mark Alexander">
  <meta name="topic-comment" content="Reference section for Motion Planning functions and variables">
  <meta name="rh-index-keywords" content="">
  <meta name="search-keywords" content="Motion Planning,mp,mp funtions">
<meta name="brsnext" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_linear_step.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/place_snapped.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Motion Planning">
        <span>Motion Planning</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1><span data-field="title" data-format="default">Motion Planning</span></h1>
  <p>In many games you want opponents, NPC's, enemies, etc. to interact with the player and show certain intelligence when moving around,&nbsp;i.e.&nbsp;you want them to avoid obstacles, plan routes and generally not bump into everything in their path! To aid in this <span data-keyref="GameMaker Name">GameMaker</span> has a series of functions that deal with motion planning. Note that while these are designed for things like game enemies, they can be used for all sorts of things like creating a smooth way to introduce text, or to create transitions, etc. However, whatever you choose to use from the list below in your game, it should be noted that in many situations a single function set will not give you a perfect solution and that you will have to "mix and match" the functions, using one or the other depending on the situation within your game.</p>
  <p>Motion planning in <span data-keyref="GameMaker Name">GameMaker</span> is dealt with by the <span class="inline2">mp_*</span>&nbsp;functions, which themselves are split into the following three groups:</p>
  <h2><label for="one">线性函数</label></h2>
  <p>此类函数尝试计算实例的无碰撞路径。计算此路径后，可以将其指定给实例以向目标移动。路径的计算将需要一些时间，但在此之后，路径的执行将会很快。当然，这只有在情况没有改变的情况下才有效。例如，如果障碍物发生变化，则可能需要重新计算路径。请再次注意，这些函数可能会失败，并且可能找不到实例的路径。</p>
  <ul class="colour">
    <li><a href="mp_linear_step.htm">mp_linear_step</a></li>
    <li><a href="mp_linear_step_object.htm">mp_linear_step_object</a></li>
    <li><a href="mp_linear_path.htm">mp_linear_path</a></li>
    <li><a href="mp_linear_path_object.htm">mp_linear_path_object</a></li>
  </ul>
  <p>&nbsp;</p>
  <h2><label for="three">潜在函数</label></h2>
  <p>这些都是基本的回避函数，对简单的Ai有好处。它们的工作方式是使实例朝着特定目标位置迈出一步，同时尽可能直接尝试，但如果需要，可以采用不同的方向。应在实例的<b>步骤事件</b>中使用这些函数。</p>
  <ul class="colour">
    <li><a href="mp_potential_settings.htm">mp_potential_settings</a></li>
    <li><a href="mp_potential_step.htm">mp_potential_step</a></li>
    <li><a href="mp_potential_step_object.htm">mp_potential_step_object</a></li>
    <li><a href="mp_potential_path.htm">mp_potential_path</a></li>
    <li><a href="mp_potential_path_object.htm">mp_potential_path_object</a></li>
  </ul>
  <p>&nbsp;</p>
  <h2><label for="two">网格函数</label></h2>
  <p>最后一种类型的函数使用更复杂的基于网格的方法(有时称为A*算法)的机制。它将更成功地找到路径(尽管它仍然可能失败)，并且会找到可能的最短路径，但是它需要你做更多的工作来设置它。</p>
  <p>The global idea is as follows - First of all we create a grid that covers the room (or the relevant part of it). You can choose to use a fine grid, which will be slower, or a coarse grid, but both of them should be based on the resolution of the room so that the path-finding is as accurate as possible. For example, if you have a room that is 400x200 pixels, you can have a grid resolution of 40, or 20, or 10... it all depends on how accurate you need the path to be and how much processing you want <span data-keyref="GameMaker Name">GameMaker</span>&nbsp;to do to generate it.</p>
  <p>接下来，对于我们想要避免的所有相关对象，我们需要确定它们重叠的栅格单元格(基于它们的边界框或精确的精灵)，并将这些单元格标记为禁止。因此，一个细胞将被标记为完全禁止，即使障碍只是部分重叠。</p>
  <p>最后，我们指定一个起始位置和一个目标位置，这两个位置都<i>必须</i>位于自由单元格中，然后函数计算这两个位置之间可能的最短路径。路径将在所有自由单元格的中心之间运行，因此，如果单元格足够大，以便放置在其中心的实例将完全位于其内部，这将是成功的。然后使用 <a href="../../Asset_Management/Paths/Paths.htm"><span class="inline">path_*</span></a> 函数将此路径分配给要跟随的实例。您应该意识到单元格大小对于此有多重要，因为单元格必须足够大，以便将移动对象放置在单元格中心，使其原点<i>完全</i>位于单元格内部。(请注意对象原点的位置。还要注意，如果对象的原点不在其中心，则可以移动路径！)另一方面，单元越小，可能存在的路径越多。如果将单元格设置得太大，则障碍物之间的洞口可能会关闭，因为所有单元格都与障碍物相交。</p>
  <ul class="colour">
    <li><a href="mp_grid_create.htm">mp_grid_create</a></li>
    <li><a href="mp_grid_destroy.htm">mp_grid_destroy</a></li>
    <li><a href="mp_grid_path.htm">mp_grid_path</a></li>
    <li><a href="mp_grid_add_cell.htm">mp_grid_add_cell</a></li>
    <li><a href="mp_grid_add_instances.htm">mp_grid_add_instances</a></li>
    <li><a href="mp_grid_add_rectangle.htm">mp_grid_add_rectangle</a></li>
    <li><a href="mp_grid_get_cell.htm">mp_grid_get_cell</a></li>
    <li><a href="mp_grid_clear_all.htm">mp_grid_clear_all</a></li>
    <li><a href="mp_grid_clear_cell.htm">mp_grid_clear_cell</a></li>
    <li><a href="mp_grid_clear_rectangle.htm">mp_grid_clear_rectangle</a></li>
    <li><a href="mp_grid_to_ds_grid.htm">mp_grid_to_ds_grid</a>&nbsp;/&nbsp;<a href="../../Data_Structures/DS_Grids/ds_grid_to_mp_grid.htm">ds_grid_to_mp_grid</a></li>
    <li><a href="mp_grid_draw.htm">mp_grid_draw</a></li>
  </ul>
  <p>&nbsp;</p>
  <p>基于网格的方法非常强大(在许多专业游戏中使用)，但它需要你仔细思考，因为你必须确定哪个区域和单元格大小足以解决游戏。此外，还必须确定必须避免哪些对象，以及精确检查是否重要。所有这些参数都极大地影响了该方法的效率。您还必须确定是否实际上有必要这样做，因为成本较低的<span class="inline2">mp_*</span>函数也可以完成这项工作。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back:&nbsp;<a href="../Movement_And_Collisions.htm">运动与碰撞</a></div>
        <div style="float:right">Next: <a href="../Collisions/Collisions.htm">碰撞</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2023 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Motion Planning
MP Functions
Motion Planning Functions
-->
  <!-- TAGS
mp_functions
-->

</body></html>