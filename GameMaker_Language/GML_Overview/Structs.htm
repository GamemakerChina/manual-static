<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "8.2.1.2";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Structs &amp; Constructors</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css">
  <script src="../../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo">
  <meta name="topic-comment" content="Page outlining the use of Structs">
  <meta name="rh-index-keywords" content="Structs">
  <meta name="search-keywords" content="structs,new,delete,struct">
<meta name="brsnext" value="GameMaker_Language/GML_Overview/Structs/Static_Structs.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Arrays.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Structs &amp; Constructors">
        <span>Structs &amp; Constructors</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1><span data-field="title" data-format="default">Structs &amp; Constructors</span></h1>
  <p><strong><a id="struct"></a>struct (结构) </strong>是保存其他变量集合的变量。结构所持有的变量可以是前面提到的任何<a href="Data_Types.htm">数据类型</a>，这些变量可以在初始结构声明之后读取和写入，也可以在声明结构之后向其添加更多变量。</p>
  <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note"> 注意</span></span> 结构体和结构体之间存在细微差别。<span data-field="title" data-format="default"> 构造函数 </span> 和 <a href="../../Quick_Start_Guide/Objects_And_Instances.htm"> 对象和实例 </a>。请参阅 <a href="Structs.htm#constructors_structs_vs_objects_instances"> 构造函数和结构与对象和对象实例 </a> 了解更多信息。</p>
  <p>结构体中使用的变量应遵循通常的变量命名方案，即：它们不能以数字开头，只能由字母数字字符和下划线"_"字符组成，还要注意结构体的内容是<em>独立于创建它的实例或函数</em>，因此，如果您愿意，您可以使用内置变量名称，例如<span class="inline2"><a href="../GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_index.htm">image_index</a></span>或<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span>和<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span>。</p>
  <p>在初始创建之后，虽然结构<i>会占用内存空间，但它们在存在时没有处理开销。结构语法如下：</i></p>
  <p class="code"><i>&lt;variable&gt;</i> =<br>
    {<br>
    <i>&nbsp; &nbsp; &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br>
    <i>&nbsp; &nbsp; &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;etc...<br>
    };
  </p>
  <p>因此，实践中的一个例子是：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World"<br>
    };</p>
  <p>以上代码在变量<span class="inline">mystruct</span>中创建实例范围结构，并使用某些值填充该结构(可以在局部、实例和全局范围内创建结构，就像任何其他变量一样-有关详细信息，请参阅<a href="Variables_And_Variable_Scope.htm">变量和变量范围</a>一节)。请注意，最初创建结构时不必填充其内容，只需执行以下操作即可创建空结构：</p>
  <p class="code">mystruct = {};</p>
  <p>然后可以在游戏代码的稍后一点将变量添加到此结构中。若要在以后添加它们，请使用点运算符(与<a href="Addressing_Variables_In_Other_Instances.htm">其他实例中的寻址变量的方法相同</a>)：</p>
  <p class="code">mystruct.newItem = "Some Text";</p>
  <p>这与初始化结构体的结果相同：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;newItem : "Some Text"<br>
    };</p>
  <p>下面是一个具有各种变量和数据类型的结构示例：</p>
  <p class="code">var _xx = 100;<br>
    mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;a : 10,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World",<br>
    &nbsp;&nbsp;&nbsp;&nbsp;c : int64(5),<br>
    &nbsp;&nbsp;&nbsp;&nbsp;d : _xx + 50,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;e : function(a, b)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a + b;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
    &nbsp;&nbsp;&nbsp;&nbsp;f : [ 10, 20, 30, 40, 50 ],<br>
    &nbsp; &nbsp; g : image_index<br>
    };</p>
  <p>在上面的代码中可以看到，您可以在结构中定义方法和使用运行时函数，还可以在结构声明中使用局部变量和实例变量。</p>
  <h3 id="inst_in_struct">结构声明中的实例变量?</h3>
  <p>您会注意到在上面的示例中，结构变量 "g" 被设置为 <span class="inline2"><a href="../GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_index.htm">image_index</a></span>，它是一个实例变量。您可能认为在这种情况下需要使用 <a href="Instance_Keywords.htm"> 关键字 </a><span class="inline">other</span> 来获取实例变量，但这不是必需的。本质上，当您定义 struct 时，冒号 ":" 左侧的所有成员变量都是 <strong><em>struct</em></strong> 变量，右侧的值和变量使用任意范围( 在本例中是一个实例)。</p>
  <p>让我们看一个简单的例子来说明这一点。假设您想要使用变量 "x" 和 "y" 定义一个结构体，并且希望将它们设置为定义该结构体的实例的 <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span> 和 <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span>。实际上，代码如下所示：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;x : x,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;y : y<br>
    };</p>
  <p>在上述代码中，结构体成员变量 <span class="inline">x</span> 和 <span class="inline">y</span> 被设置为实例变量 <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span> 和 <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span> 中保存的值，因为冒号右侧的 <span class="inline2">:</span> 指的是定义结构体的实例。值得注意的是，这意味着您 <em> 不能 </em> 使用结构体成员变量来定义结构体声明中的后续变量。例如，以下内容会给您带来错误：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp; &nbsp; a : 10,<br>
    &nbsp; &nbsp; b : 10,<br>
    &nbsp; &nbsp; c : a + b<br>
    }</p>
  <p>发生错误的原因是变量 <span class="inline">a</span> 和 <span class="inline">b</span> 实际上是在定义结构的范围内进行求值 (它们位于冒号 <span class="inline2">:</span> 的右侧)，并且 <em> 不是 </em> 结构体本身中定义的。<strong></strong></p>
  <p class="note" style="padding-left: 20px;"><span data-conref="../../assets/snippets/Tag_important.hts"><span class="important"> 重要提示 </span></span>您不能使用任何内置的 <strong> 全局变量 </strong> 作为结构体成员名称，例如：<span class="inline2"><a href="../GML_Reference/General_Game_Control/game_id.htm">game_id</a></span><font face="menlo, consolas, monospace"><b></b></font> 或 <span class="inline2"><a href="../GML_Reference/Debugging/fps.htm">fps</a></span>。您可以在 <a href="Struct_Forbidden_Variables.htm"> 结构禁止变量 </a> 上找到这些全局变量的完整列表。</p>
  <h3>同名变量初始化的简写</h3>
  <p>使用同名的现有变量(局部变量或实例变量)的值初始化的结构变量可以使用简写表示法编写。而不是写：</p>
  <p class="code">var a = 12;<br>
    b = 14;<br>
    <br>
    mystruct =&nbsp;<br>
    {<br>
    &nbsp; &nbsp; a : a,<br>
    &nbsp; &nbsp; b : b,<br>
    &nbsp; &nbsp; c : 101<br>
    }
  </p>
  <p>你可以这样写：</p>
  <p class="code">var a = 12;<br>
    b = 14;<br>
    <br>
    mystruct =&nbsp;<br>
    {<br>
    &nbsp; &nbsp; a,<br>
    &nbsp; &nbsp; b,<br>
    &nbsp; &nbsp; c: 101<br>
    }
  </p>
  <p>在这两种情况下，<span class="inline2">mystruct.a</span>将被赋值为<span class="inline2">12</span>，而<span class="inline2">mystruct.b</span>将被赋值为<span class="inline2">14</span>，因为它将在初始化结构的作用域中查找同名的变量。</p>
  <h3>访问结构变量</h3>
  <p>定义结构后，可以使用"点"表示法访问其中的数据，如下所示：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World"<br>
    }<br>
    <br>
    mystring = mystruct.b + string(mystruct.a);
  </p>
  <p>您还可以对结构中的变量执行操作，或者在函数中使用它们，就像对待任何其他变量一样。例如：</p>
  <p class="code">mystruct.a += 1;<br>
    mystruct.b = mystruct.a + 20;<br>
    mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);</p>
  <p>最后，结构中可以嵌套其他结构，如下所示：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;a :<br>
    &nbsp; &nbsp; {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aa : "This is an example"<br>
    &nbsp;&nbsp;&nbsp;&nbsp;},<br>
    &nbsp;&nbsp;&nbsp;&nbsp;b :<br>
    &nbsp; &nbsp; {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bb : "And another one"<br>
    &nbsp;&nbsp;&nbsp;&nbsp;},<br>
    };</p>
  <p>要访问此类嵌套结构，仍需使用点符号，如下所示：</p>
  <p class="code">var _str = mystruct.a.aa + " " + mystruct.b.bb;<br>
    show_debug_message(_str);</p>
  <p>访问结构中数据的另一种方法是使用 <span class="inline2"><a href="Language_Features/with.htm">with</a></span> 语句。例如，您可以这样做：</p>
  <p class="code">with (mystruct)<br>
    {<br>
    &nbsp; &nbsp; a += other.x;<br>
    }</p>
  <p>将 <span class="inline2">with</span> 配合使用会将代码的作用域更改为给定的结构，您可以在其中操作结构作用域中的成员变量。请注意，在本例中，我们还使用了<a href="Instance_Keywords.htm"> <span class="inline">other</span> 关键字</a>。这就像在实例中将 <span class="inline2">with</span> 一起使用时一样，并将引用实际运行代码块的实例 (或结构)。</p>
  <p>访问结构中数据的最后一种方法是使用结构访问器 <span class="inline2"><a href="Accessors.htm#$">$</a></span>。这允许使用字符串访问结构变量，用于读取：</p>
  <p class="code">var _value = mystruct[$ "x"];</p>
  <p>和写入：</p>
  <p class="code">mystruct[$ "x"] = 200;</p>
  <p>如果你需要使用字符串来访问一个结构变量，那么<a href="../GML_Reference/Variable_Functions/variable_get_hash.htm">获取它的hash</a>并在<a href="../GML_Reference/Variable_Functions/struct_get_from_hash.htm">read</a>/<a href="../GML_Reference/Variable_Functions/struct_set_from_hash.htm">write</a>中使用它来访问变量会更快。</p>
  <p>当不再需要某个结构体时，可以使用 <a href="Language_Features/delete.htm"><span class="inline">delete</span></a> 运算符将其从内存中删除，该运算符将该结构体标记为可以进行垃圾回收。这并不是严格要求的，因为如果您的代码中不再引用该结构，<a class="tooltip" title="垃圾回收是游戏代码中的一部分，是一种自动化工具，用于在代码中不再引用某些东西（如数组和结构）时从内存中删除它们，而无需您明确删除它们。"> 垃圾收集器 </a> 可能会自动执行此操作，但这样做是一种很好的做法，我们建议您这样做 (例如，在 <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm"> 清理事件 </a> 中调用 <span class="inline2"><a href="Language_Features/delete.htm">delete</a></span> 显式告诉垃圾收集器要删除实例范围结构)。这是一个例子：</p>
  <p class="code">// Create event<br>
    mystruct =<br>
    {<br>
    &nbsp; &nbsp; pos_x : x,<br>
    &nbsp; &nbsp; pos_y : y,<br>
    &nbsp; &nbsp; count : 1000<br>
    };<br>
    <br>
    // Clean Up event<br>
    delete mystruct;
  </p>
  <h2 id="constr">构造函数</h2>
  <p>您还可以使用<a href="Script_Functions.htm">脚本函数</a>或<a href="Method_Variables.htm">方法</a>来创建可用于生成新结构的函数，这需要使用函数的<span class="inline">构造函数</span>关键字，以及从此类函数创建结构时使用<a href="Language_Features/new.htm"><span class="inline">new</span></a>运算符。请参阅以下函数：</p>
  <p class="code">function Vector2(_x, _y) <strong>constructor</strong><br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br>
    <br>
    &nbsp; &nbsp; static Add = function(_vec2)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec2.x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec2.y;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
  </p>
  <p>或者，使用方法变量语法：</p>
  <p class="code">Vector2 = function(_x, _y) constructor<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;static Add = function(_vec2)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec2.x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec2.y;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
  </p>
  <p>此处我们创建一个名为<span class="inline">Vector 2</span>的函数，并告诉<span data-keyref="GameMaker Name">GameMaker</span>此函数用于通过在其定义后添加<span class="inline">构造函数</span>关键字来创建结构。然后可以这样调用此构造函数：</p>
  <p class="code">v2 = new Vector2(10, 10);</p>
  <p>变量<span class="inline">v2</span>现在将包含带有变量<span class="inline">x</span>和<span class="inline">y</span>以及<a href="Functions/Static_Variables.htm">static</a><a href="Method_Variables.htm">方法变量</a><span class="inline">Add</span>的结构。</p>
  <p>您还可以在构造函数中使用可选参数：</p>
  <p class="code">function Vector2(<strong>_x = 0, _y = 0</strong>) constructor<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br>
    }</p>
  <p>如果在调用函数时未指定<span class="inline">_x</span>和<span class="inline">_y</span>参数，则此构造函数现在将使用<span class="inline">0</span>。这意味着您可以创建新的<span class="inline"> Vector2 </span>结构，而无需指定任何参数：</p>
  <p class="code">empty_vector = new Vector2();</p>
  <h2>继承</h2>
  <p>以这种方式创建的函数还将支持单<b>继承</b>，即：您可以创建一个从另一个构造函数继承数据的构造函数。</p>
  <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span> 在使用继承时，不能使用方法变量来定义构造函数，只能使用脚本函数。</p>
  <p>例如，我们在上面创建了&nbsp;<span class="inline">Vector2</span>&nbsp;构造函数，因此我们可以使用它作为另一个构造函数的“父”函数，我们将其命名为&nbsp;<span class="inline">Vector3</span>:</p>
  <p class="code">function <strong>Vector3(_x, _y, _z) </strong><strong>:</strong><strong> Vector2(_x, _y) </strong>constructor<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;z = _z;<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;static Add = function( _vec3 )<br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec3.x;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec3.y;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z += _vec3.z;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
  </p>
  <p>如您所见，在定义函数时，我们使用冒号"<span class="inline">:</span>"将新构造函数与要从中继承的父构造函数分开。子构造函数(<span class="inline">Vector 3</span>)将<span class="inline">_x</span>和<span class="inline">_y</span>参数传递到父构造函数(<span class="inline">Vector 2</span>)中，父构造函数用于首先运行父构造函数，然后执行子构造函数。这样，子构造函数就可以获取父项的变量(<span class="inline">x</span>和<span class="inline">y</span>)，并且还可以定义自己的变量(<span class="inline">z</span>)。</p>
  <p>您还可以将值传递给父构造函数，以便某个子构造函数始终向其父构造函数提供相同的值：</p>
  <p class="code">function item(damage) constructor<br>
    {<br>
    &nbsp;&nbsp; &nbsp;my_damage = damage;<br>
    }<br>
    <br>
    function basic_sword() : item(10) constructor {}<br>
    <br>
    var _basic_sword = new basic_sword();<br>
    show_debug_message(_basic_sword.my_damage); // Prints 10
  </p>
  <p>这意味着BasicSword的damage将始终为<span class="inline">10</span>，因为它将该值传递给其父构造函数，而不管其自身的参数是什么。</p>
  <p>请注意，为子构造函数中的参数指定缺省值将覆盖该参数的父级缺省值。请参见以下示例：</p>
  <p class="code">function parent(value = 10) constructor<br>
    {<br>
    &nbsp;&nbsp; &nbsp;show_debug_message(value);<br>
    }<br>
    <br>
    function child(value = 20) : parent(value) constructor<br>
    {<br>
    &nbsp;&nbsp; &nbsp;show_debug_message(value);<br>
    }<br>
    <br>
    var _child = new child();
  </p>
  <p>这两个构造函数都将向输出日志打印<span class="inline">20</span>，因为这是子构造函数设置的参数的默认值，并且已将相同的值传递到父构造函数。</p>
  <p>有关<span class="inline">new</span>和<span class="inline">delete</span>运算符的详细信息，请参阅以下页面：</p>
  <ul class="colour">
    <li><a href="Language_Features/new.htm"><span class="inline">new</span></a></li>
    <li><span class="inline"><a href="Language_Features/delete.htm"><span class="inline">delete</span></a> </span></li>
  </ul>
  <h3>检查构造函数继承</h3>
  <p>您可以使用 <span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span> 来检查结构是否属于给定的构造函数，或者是否将该构造函数作为父构造函数。</p>
  <div data-conref="../../assets/snippets/is_instanceof_example.hts">
  <p class="code">function item() constructor {}<br>
    <br>
    function potion() : item() constructor {}<br>
    <br>
    function enemy() constructor {}<br>
    <br>
    var _potion = new potion();<br>
    <br>
    show_debug_message(is_instanceof(_potion, potion)); // true (1)<br>
    show_debug_message(is_instanceof(_potion, item)); // true (1)<br>
    show_debug_message(is_instanceof(_potion, enemy)); // false (0)
  </p>
  <p>上面的代码显示了三个构造函数：<span class="inline2">item</span>，<span class="inline2">potion</span>，它是 <span class="inline2">item</span> 的子类，以及 <span class="inline2">enemy</span>，它是一个单独的构造函数。</p>
  <p>它从 <span class="inline2">potion</span> 构造函数创建一个结构。使用 <span class="inline2">is_instanceof()</span>，我们可以检查新结构：</p>
  <ul class="colour">
    <li>是一个 <span class="inline2">potion</span></li>
    <li>是一个 <span class="inline2">item</span></li>
    <li>不是一个 <span class="inline2">enemy</span></li>
  </ul>
  <p>通过这种方式，您可以检查结构是否"是"某物，因为 <strong>potion 是 item</strong>，因此它为两个构造函数返回 <span class="inline2">true</span>。然而，如果不是真的，反过来：<strong> item 不是 potion </strong>。</p>

</div>
  <p>该功能利用了"静态结构"。请参阅：<a href="Structs/Static_Structs.htm">静态结构</a></p>
  <h2>字符串输出</h2>
  <p>关于结构的最后一件事是，您可以更改结构输出到控制台的内容以进行调试。默认情况下，在结构体上调用函数 <span class="inline3_func"><a href="../GML_Reference/Debugging/show_debug_message.htm">show_debug_message</a></span> 将输出该结构体的内容 (如上所示)。不过，可以通过向名为 <span class="inline"><a id="A"></a>toString</span> 的结构添加专门命名的方法来自定义此消息：</p>
  <p class="code">mystruct =<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World",<br>
    <br>
    &nbsp; &nbsp; toString&nbsp;: function()<br>
    &nbsp; &nbsp; {<br>
    &nbsp; &nbsp; &nbsp; &nbsp; return "This struct says " + b + ",&nbsp;" + string(a) + " times!";<br>
    &nbsp; &nbsp; }<br>
    }<br>
    show_debug_message(mystruct);
  </p>
  <p>现在，当调用<span class="inline3_func"><a href="../GML_Reference/Debugging/show_debug_message.htm">show_debug_message</a></span>函数时，将使用<span class="inline">toString</span>方法生成输出，并且通过上面的示例，您将得到：</p>
  <p class="code">This struct says Hello World, 20 times!</p>
  <p>请注意，您还可以对结构体引用调用<span class="inline3_func"><a href="../GML_Reference/Strings/string.htm">string</a></span>函数，并使用该函数将内容(或<span class="inline">toString</span>方法)显示到屏幕上，或者将其保存到文件中，或者无论如何，例如：</p>
  <p class="code">var _str = string(mystruct);<br>
    draw_text(32, 32, _str);</p>
  <h2 id="constructors_structs_vs_objects_instances">构造函数 和 结构与对象 和 对象实例</h2>
  <p>构造函数和结构与<a href="../../Quick_Start_Guide/Objects_And_Instances.htm">对象和实例</a>类似，因为它们也包含可以执行的变量和方法。然而，它们之间有一些重要的区别：</p>
  <ul class="Disc">
    <li>结构体是通过使用<span class="inline2"><a href="Language_Features/new.htm">new</a></span>运算符调用构造函数、创建结构体文字<span class="inline2">{ }</span>或由某个函数返回来创建的。另一方面，实例是使用<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_create_depth.htm">instance_create_depth</a></span>或<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_create_layer.htm">instance_create_layer</a></span>从对象创建的。</li>
    <li>结构只是变量，没有事件。<span data-keyref="GameMaker Name">GameMaker</span>为所有实例执行事件，但不为结构执行事件。与对象的事件相比，结构体的方法永远不会自行执行，您必须在游戏代码中自己调用它。这可以来自<a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">对象事件</a>、<a href="../GML_Reference/Time_Sources/Time_Sources.htm">时间源</a>或更具体的位置，您可以在其中"利用"<span data-keyref="GameMaker Name">GameMaker</span>的游戏循环，例如层和相机开始/结束脚本。</li>
    <li>结构体可以有静态变量，但对象实例不能。<a href="../../The_Asset_Editors/Object_Properties/Object_Variables.htm">对象变量</a>并不等同于静态变量;它们不属于该对象，而是为在 Create 事件运行之前分配给从该对象创建的实例的<a href="Variables/Instance_Variables.htm">实例变量</a>提供默认值。</li>
  </ul>
  <h2>结构体函数</h2>
  <p>最后，您可以在结构上使用许多运行时函数来获取它们包含的变量以及其他一些内容。您可以在<a href="../GML_Reference/Variable_Functions/Variable_Functions.htm#struct_functions">结构函数</a>下找到它们。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div>
        <div style="float:right">Next:&nbsp;<a href="Structs/Static_Structs.htm">静态结构</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Structs
struct
constructor
-->
  <!-- TAGS
structs
-->

</body></html>