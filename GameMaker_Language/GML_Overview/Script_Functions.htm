<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "8.2.1.1_5";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Script Functions And Variables</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css">
  <script src="../../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo">
  <meta name="topic-comment" content="Page outlining the use of scripts to create functions and global variables and macros">
  <meta name="rh-index-keywords" content="Script Functions And Variables">
  <meta name="search-keywords" content="user defined functions,script functions,gmcallback_,gmcallback">
<meta name="brsnext" value="GameMaker_Language/GML_Overview/Method_Variables.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Expressions_And_Operators.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Script Functions And Variables">
        <span>Script Functions And Variables</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>脚本函数和变量</h1>
  <p>脚本资源本质上是一个或多个用户定义的函数或变量的集合，您可以在<a href="../../The_Asset_Editors/Scripts.htm">脚本编辑器</a>中将这些函数或变量自己编写为代码片段。您在脚本中定义的函数可以解析表达式、返回值或执行 GameMaker 语言允许的任何其他操作，就像内置的<a href="Runtime_Functions.htm">运行时函数</a>一样。</p>
  <p>如果您有在多个位置或多个对象中使用的代码块，或者您希望以模块化方式跨多个对象使用代码块，则通常应使用脚本函数。使用脚本定义函数意味着您只需在需要时更改函数一次，并且调用该函数的每个对象都会"接收"该更改。</p>
  <p>从组织的角度来看，脚本也非常方便，因为它们允许您创建属于特定类别的函数组 - 例如，您可能有几个与游戏中实例之间的碰撞相关的函数，因此您可以创建一个"<span class="inline">Collision_Functions</span>"脚本并将所有这些函数一起存储在其中。</p>
  <p>另请参阅：<a href="Script_Functions_vs_Methods.htm">脚本函数与方法</a></p>
  <h2>创建函数</h2>
  <p>创建包含函数的脚本时，必须使用以下格式创建函数：</p>
  <p class="code"><span>function name( parameter1, parameter2, ... )<br>
      {</span><br>
    <span>&nbsp; &nbsp; statement1;</span><br>
    <span>&nbsp; &nbsp; statement2;</span><br>
    <span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br>
    <span>}</span>
  </p>
  <p>or:</p>
  <p class="code">name =&nbsp;function( parameter1, parameter2, ... )<br>
    <span>{</span><br>
    <span>&nbsp; &nbsp; statement1;</span><br>
    <span>&nbsp; &nbsp; statement2;</span><br>
    <span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br>
    <span>}</span>
  </p>
  <p class="note">要在 GML Visual 中创建函数，请使用<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Common/Declare_A_New_Function.htm">声明新函数</a>。启用其"Temp"选项来创建方法变量(上面显示的第二种语法)。</p>
  <p>不过，一般来说，您会为脚本函数使用<em>第一个</em>形式，因为它将将该函数定义为专门的脚本函数，这意味着它将在<a href="Variables_And_Variable_Scope.htm">作用域</a>中<strong>全局</strong>，并被分配<strong>脚本索引</strong>，并且不需要<span class="inline">全局</span>前缀来识别它，因为编译器会将其识别为脚本函数。</p>
  <p>使用第二种形式将生成一个全局范围的<a href="Method_Variables.htm">方法变量</a>，因此它<em>不会被 IDE 识别为脚本函数，并且需要使用</em>global<span class="inline">前缀在您的代码中引用时。</span></p>
  <p class="note"><span class="note">注意</span>您可以通过在脚本中使用这两种表单，然后对每个表单调用运行时函数<a href="../GML_Reference/Variable_Functions/typeof.htm">typeof()</a>来进行检查。一个将被归类为"数字" - 因为它返回脚本索引 ID - 另一个将被归类为"方法"。</p>
  <h2>参数/参数</h2>
  <p>您可以为函数定义自己的参数/参数，这些参数/参数将作为局部变量提供给函数，并且可用于该函数内的任何目的：</p>
  <p class="code">function move(<strong>spd, dir</strong>)<br>
    {<br>
    &nbsp;&nbsp; &nbsp;speed = <strong>spd</strong>;<br>
    &nbsp;&nbsp; &nbsp;direction = <strong>dir</strong>;<br>
    }</p>
  <p>该函数接受两个参数，并将它们的值应用于实例的<span class="inline">速度</span>和<span class="inline">方向</span>变量。现在可以像任何运行时函数一样调用它，并且可以将参数传递给它：</p>
  <p class="code">var _mouse_dir = point_direction(x, y, mouse_x, mouse_y);<br>
    <br>
    <strong>move(4, _mouse_dir);</strong>
  </p>
  <h2>基于索引的参数</h2>
  <p>还可以通过 <span class="inline">argumentN</span> 变量 (<em>argument0、argument1 等 </em>) 或 <a href="Variables/Builtin_Global_Variables/argument.htm"><span class="inline">argument[]</span></a> 数组 (<em>argument[0] 、参数 [1] 等 </em>)。</p>
  <p>您可以使用<a href="Variables/Builtin_Global_Variables/argument_count.htm"><span class="inline">argument_count</span></a>获取传递到函数中的参数数量，从而允许传入可变数量的参数。</p>
  <p class="code">function print(){<br>
    &nbsp;&nbsp; &nbsp;var _str = "";<br>
    <br>
    &nbsp;&nbsp; &nbsp;for (var i = 0; i &lt; argument_count; i ++)<br>
    &nbsp;&nbsp; &nbsp;{<br>
    &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;_str += string(argument[i]);<br>
    &nbsp;&nbsp; &nbsp;}<br>
    <br>
    &nbsp;&nbsp; &nbsp;show_debug_message(_str);<br>
    }<br>
    <br>
    // In an object<br>
    print("Player : ", current_time, " : ", id, " : fired");
  </p>
  <p>此<span class="inline2">print()</span>函数循环遍历所有传递的参数，并将它们添加到字符串变量中。然后将该字符串打印到输出日志中。</p>
  <p>现在，您可以使用任意数量的字符串来调用此函数，这些字符串将全部连接在一起。</p>
  <h2>可选参数</h2>
  <p>如果未向函数提供参数，则其值将为<span class="inline">未定义</span>。您可以使用它来定义<em>可选</em>参数，并通过检查参数是否等于<span class="inline">未定义</span>来检查参数是否已传入。不过，您也可以显式定义参数的默认值，当未传入该参数时，将使用该默认值来代替<span class="inline">undefined</span>。</p>
  <p>您可以使用等号(<span class="inline">=</span>) 将此类默认值分配给参数，使其成为可选变量：</p>
  <p class="code">function move(spd, <strong>dir = 90</strong>)<br>
    {<br>
    &nbsp;&nbsp; &nbsp;speed = spd;<br>
    &nbsp;&nbsp; &nbsp;direction = dir;<br>
    }</p>
  <p>如果调用上述函数时未传入<span class="inline">dir</span>参数，则其值将默认为<span class="inline">90</span>，将实例向上移动。</p>
  <p class="note"><span class="tip">提示</span>您可以省略函数调用中的参数，它们将默认为<span class="inline">undefined</span>(或函数定义的该参数的默认值)。<br><br>例如，编写<span class="inline">my_func(0 ,,,1)</span>与编写<span class="inline">my_func(0, undefined, undefined, 1)</span>相同。</p>
  <hr>
  <p>可选变量的默认值可以是表达式，因此，例如，您可以在定义可选变量时使用变量和调用函数。请注意，只有在函数调用中未提供其可选参数时，才会执行此类表达式。请参阅以下日志记录功能示例：</p>
  <p class="code">function log(text = "Log", object = object_index, time = date_datetime_string(date_current_datetime()))<br>
    {<br>
    &nbsp;&nbsp; &nbsp;var _string = "[" + string(time) + "] ";<br>
    &nbsp;&nbsp; &nbsp;_string += object_get_name(object) + ": ";<br>
    &nbsp;&nbsp; &nbsp;_string += text;<br>
    &nbsp;&nbsp; &nbsp;<br>
    &nbsp;&nbsp; &nbsp;show_debug_message(_string);<br>
    }</p>
  <p>该函数采用三个参数，其中第一个参数默认为字符串常量，第二个参数默认为实例变量(在调用实例的范围内)，第三个参数默认为调用函数以检索当前日期和时间。现在可以使用最多三个参数调用此函数，如以下示例所示：</p>
  <p class="code">log();<br>
    // Prints:&nbsp;[09-Jun-21 12:34:37 PM] Object1: Log<br>
    <br>
    log("Player Shot", obj_player, 10);<br>
    // Prints:&nbsp;[10] obj_player: Player Shot
  </p>
  <h2>JSDoc</h2>
  <p>我们还建议您添加注释来定义函数的属性(有关更多详细信息，请参阅有关<a href="../../The_Asset_Editors/Code_Editor_Properties/JSDoc_Script_Comments.htm">JSDoc 注释</a>的部分)，这样简单的脚本将如下所示：</p>
  <p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;log(message);<br>
    /// @param {string}&nbsp; message&nbsp;&nbsp;The message to show<br>
    /// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Show a message whenever the function is called.<br>
    <br>
    function log(message)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(message);<br>
    }
  </p>
  <p>可以使用如上所示的相同格式在脚本资源中一个接一个地添加脚本的附加函数。</p>
  <p><img alt="Multiple Functions In One Script" class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/Multiple_Functions_Scripts.png"></p>
  <h2>返回值</h2>
  <p>脚本中的函数也可以返回值，就像运行时函数一样，因此它们可以在表达式中使用。为此，您可以使用<a href="Language_Features/return.htm"><span class="inline">return</span></a>语句：</p>
  <p class="code">return &lt;expression&gt;</p>
  <p>应该注意的是，<strong><i>函数的执行在 return 语句</i></strong>处结束，这意味着<strong>return</strong>被调用之后的任何代码<i>都不会运行</i>。下面是一个来自名为"<span class="inline">sqr_calc</span>"的函数的简短示例函数，该函数计算传递给它的任何值的平方，如果给定值不是实数，它会使用<strong>return</strong>结束尽早调用该函数，因此实际计算永远不会运行：</p>
  <p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqr_calc(val);<br>
    /// @param {real}&nbsp;&nbsp;val &nbsp;The value to calculate the square of<br>
    /// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate the square of the given value<br>
    <br>
    function sqr_calc(val)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if (!is_real(val)) <br>
    &nbsp;&nbsp;&nbsp;&nbsp;{<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;return (val&nbsp;* val);<br>
    }
  </p>
  <p>请注意，如果您创建的脚本函数<em>没有</em>返回值，那么在您的代码中检查是否有返回值，默认情况下您将获得值<span class="inline">未定义</span>。</p>
  <p>要从一段代码中调用脚本函数，只需使用与调用任何运行时函数相同的方式即可 - 即，在括号中写入函数名称和参数值。因此，上面的脚本将被这样调用：</p>
  <p class="code">if (keyboard_check_pressed(vk_enter)) <br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;val = scr_sqr(amount);<br>
    }</p>
  <p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">注意</span></span>当在代码编辑器中的脚本中使用您自己的函数时，您可以按<span><img alt="F1 Icon" class="icon" height="20" src="../../assets/Images/Icons/Icon_f1.png" width="55"></span>或在函数名称上单击鼠标中键<span><img alt="MMB Icon" class="icon" src="../../assets/Images/Icons/Icon_MMB.png"></span>以打开脚本包含它以供直接编辑。</p>
  <h2>脚本名称与函数名称</h2>
  <p>请务必了解脚本<i>名称</i><b>独立于它们包含的函数</b>，因此您可以用更"常识"的方式命名您的脚本，即：您的所有 AI 函数都可以采用脚本"<span class="inline">Enemy_AI</span>"并包含<span class="inline2">ai_target_pos()</span>、<span class="inline2">ai_alert_level()</span>、<span class="inline2">ai_state()</span>等函数。</p>
  <p>但是，您仍然可以将脚本命名为与您在其中定义的函数相同的名称并调用该脚本，例如如果您想要每个脚本一个函数(这对于制作可重用库非常有用，因此所有函数都显示在资源浏览器中)。执行此操作时，由于<span data-keyref="GameMaker Name">GameMaker</span>存储资源引用的方式，了解脚本引用的行为方式以避免代码错误非常重要。</p>
  <p>例如，考虑从实例的事件调用的以下代码：</p>
  <p class="code">function indirectCall(func, arg)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;func(arg);<br>
    }<br>
    <br>
    indirectCall(myscript, arg);
  </p>
  <p>上述代码尝试在方法内调用名为<span class="inline2">myscript</span>的脚本，在本例中将会失败。这是因为内联函数实际上使用脚本资源的<em>索引</em>，而不是实际调用脚本函数 - 例如：如果脚本索引解析为"4"，则该函数本质上是调用<strong>4(arg)</strong>，这没有意义。</p>
  <p>您可以采取以下两项措施来解决此问题：</p>
  <ol>
    <li>将脚本索引转换为<a href="../GML_Reference/Variable_Functions/method.htm">方法</a>，然后将其作为参数传递</li>
    <li>使用<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Scripts/script_execute.htm">script_execute</a></span>调用传递的脚本引用</li>
  </ol>
  <p>Both ways are shown below:</p>
  <p class="code">// 1<br>
    function indirectCall(func, arg)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;func(arg);<br>
    }<br>
    <br>
    indirectCall(method(undefined, myscript), arg);<br>
    <br>
    // 2<br>
    function indirectCall(func, arg)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;script_execute(func, arg);<br>
    }<br>
    <br>
    indirectCall(myscript, arg);
  </p>
  <div data-conref="../../assets/snippets/Script_empty_reference_error.hts">
  <p class="note"><span class="note">注意</span>请记住，如果您的脚本<strong>完全为空</strong>，则它不会加载到已编译的游戏中，并且将变得不存在;这意味着尝试引用此类脚本资源将使您的游戏崩溃。请注意，这仅适用于完全空的脚本，因此即使您的脚本仅包含注释，它仍然会包含在编译的游戏中。</p>

</div>
  <h2>脚本范围</h2>
  <p>这让我们了解了有关脚本及其包含的函数的最后也是最重要的一点：脚本在<b>全局</b>级别进行解析，并将<strong>在游戏一开始就进行编译</strong>。这意味着，<em>技术上</em>脚本中的所有函数都是"未绑定的"<a href="Method_Variables.htm">方法变量</a>，并且脚本中函数外部声明的任何变量都将被视为<a href="Variables/Global_Variables.htm">全局变量</a>。例如，考虑这个脚本：</p>
  <p class="code">function Foo()<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;// Do something<br>
    }<br>
    blah = 10;<br>
    function Bar()<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;// Do something else<br>
    }</p>
  <p>在上述示例中，我们不仅定义了函数<span class="inline">Foo</span>和<span class="inline">Bar</span>，还定义了变量<span class="inline">blah</span>，并且所有这些都被视为在<b>global</b>范围内创建。这些函数不需要<span class="inline">global</span>关键字来识别，因为编译器知道这些函数是脚本的一部分，但如果您想访问<span class="inline">blah</span>，则需要执行以下操作：</p>
  <p class="code">val = global.blah;</p>
  <p>也就是说，我们建议您在脚本中创建全局变量时<b>始终显式键入全局变量</b>，以防止以后出现任何问题。脚本也是定义任何<strong>宏</strong>或<strong>枚举</strong>(<a href="Variables/Constants.htm">常量</a>)的理想位置，因为将它们添加到函数外部的脚本中也意味着将在游戏之前创建它们以供使用代码实际上开始运行。下面是为游戏创建不同全局范围值的脚本示例：</p>
  <p class="code">/// Initialise All Global Scope Values And Constants<br>
    global.player_score = 0;<br>
    global.player_hp = 100;<br>
    global.pause = false;<br>
    global.music = true;<br>
    global.sound = true;<br>
    <br>
    enum rainbowcolors<br>
    {<br>
    &nbsp; &nbsp; red,<br>
    &nbsp; &nbsp; orange,<br>
    &nbsp; &nbsp; yellow,<br>
    &nbsp; &nbsp; green,<br>
    &nbsp; &nbsp; blue,<br>
    &nbsp; &nbsp; indigo,<br>
    &nbsp; &nbsp; violet<br>
    }<br>
    <br>
    #macro weapon_num&nbsp;3<br>
    #macro weapon_gun&nbsp;0<br>
    #macro weapon_bomb&nbsp;1<br>
    #macro weapon_knife 2
  </p>
  <p>请注意所有这些常量是如何在任何函数调用之外设置的，这意味着它们将在其他所有操作之前并在<em>全局</em>范围内进行初始化。这意味着，如果您想使用脚本来初始化<em>实例</em>范围内的变量，则必须将它们包装在函数中，例如：</p>
  <p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_enemy();<br>
    /// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialise enemy instance vars<br>
    <br>
    function init_enemy()<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;hp = 100;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;dmg = 5;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;mana = 50;<br>
    }
  </p>
  <p>因此，脚本可用于在游戏开始之前生成宏、枚举和全局变量，以便随时使用它们，并且它们还可以用于创建可以使用的"未绑定"方法(用户定义的函数)在您的游戏中，例如 GML 运行时函数。</p>
  <p>关于脚本函数，最后需要注意的一点是，如果您正在针对<strong>Web</strong>进行开发(即：以<strong>HTML5</strong>为目标)，则在向脚本添加函数时可以使用一个附加函数协议，即在函数名称前加上<span class="inline">gmcallback_</span>前缀，例如：</p>
  <p class="code">gmcallback_create_button</p>
  <p>使用上述函数名称意味着函数<span class="inline">gmcallback_create_button()</span>不会被混淆，因此可以在 JavaScript 扩展和游戏的其他区域中使用，例如，在使用<a href="../GML_Reference/Web_And_HTML5/Web_And_HTML5.htm"><span class="inline">clickable_*</span></a>功能。</p>
  <h2>静态变量</h2>
  <p>函数还可以使用静态变量，这些变量在每次函数调用期间都保持其值。请<a href="Functions/Static_Variables.htm">阅读此页面</a>了解更多信息。</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div>
        <div style="float:right">Next: <a href="Method_Variables.htm">方法变量</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Script Functions
User Defined Functions
function
gmcallback
-->
  <!-- TAGS
script_functions
-->

</body></html>