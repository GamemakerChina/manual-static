<!--?xml version="1.0" encoding="utf-8" ?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../../../..";
    gCommonRootRelPath = "../../../..";
    gTopicId = "8.2.2.6.8";
  
//]]></script>

  <script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css">
  <link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css">
  <meta name="topic-status" content="Draft">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Surfaces</title>
  <meta name="generator" content="Adobe RoboHelp 2022">
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css">
  <script src="../../../../assets/scripts/main_script.js" type="module"></script>
  <meta name="rh-authors" content="Mark Alexander">
  <meta name="topic-comment" content="Reference section for the Surface functions and variables">
  <meta name="rh-index-keywords" content="">
  <meta name="search-keywords" content="Surfaces,application_surface,application surface,app surface">
<meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_exists.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_submit_ext.htm"></head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Surfaces">
        <span>Surfaces</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1><span data-field="title" data-format="default">Surfaces</span></h1>
  <h2>Application Surface</h2>
  <p>In the normal draw events, <span data-keyref="GameMaker Name">GameMaker</span> doesn't actually draw directly to the screen, but rather draws to a <b>surface</b> called the <i>application surface</i>.</p>
  <p>This surface is basically a blank "canvas" that can be manipulated before being drawn to the screen when needed, and in most cases <span data-keyref="GameMaker Name">GameMaker</span> handles this for you (although you can also manipulate it yourself in code for shaders, scaling and many other things - further details are given below).</p>
  <h2>Custom Surfaces</h2>
  <p>Apart from the application surface, you can also create your own surfaces and use them to create stunning or subtle special effects in your game.</p>
  <p>For example, you can use surfaces to "catch" instances, which can then be destroyed, and in this way you can create a decal effect where the sprite for the instance is displayed on the surface as if it still existed, permitting graphical effects like debris, blood, etc. without any real processing overhead.</p>
  <p>Another thing you can do with surfaces is use them as textures to be manipulated, or to create sprites "on the fly", or to create complex overlays. In fact, the uses for surfaces are endless!</p>
  <h2>Using Surfaces</h2>
  <p>表面的基本用途如下：</p>
  <ul class="colour">
    <li>You first create a variable to hold the surface, e.g. in the Create event:</li>
  </ul>
  <p class="code">surf = -1;</p>
  <ul class="colour">
    <li>In a Draw event (or any other event)&nbsp;<em>before</em>&nbsp;you want to draw something to the surface, do a check to see if it exists, and if not, create it:</li>
  </ul>
  <p class="code">if (!surface_exists(surf))<br>
    {<br>
    &nbsp; &nbsp; surf = surface_create(960, 540);<br>
    }</p>
  <ul class="colour">
    <li>In case the surface is automatically removed from the memory while you need it, this will catch that and recreate the surface.</li>
    <li>You would then set the drawing target to the surface rather than the display, when you actually want to draw something to it, e.g. in the Draw event:</li>
  </ul>
  <p class="code">surface_set_target(surf);</p>
  <ul class="colour">
    <li>Next, you would draw the things you wish as well as perform any other manipulations. It is recommended to clear the surface before drawing anything.</li>
  </ul>
  <p class="code">draw_clear_alpha(c_black, 0);<br>
    draw_sprite(spr_icon, 0, 48, 48);</p>
  <ul class="colour">
    <li>Once you are done drawing to the surface, you reset the draw target so that all further drawing happens on the screen again.</li>
  </ul>
  <p class="code">surface_reset_target();</p>
  <ul class="colour">
    <li>Finally, you would draw the surface (or <a href="../Textures/texture_set_stage.htm">use it in a shader</a>, or whatever is required).</li>
  </ul>
  <p class="code">draw_surface(surf, 0, 0);</p>
  <ul class="colour">
    <li>When you no longer need the surface, remove it from memory:</li>
  </ul>
  <p class="code">surface_free(surf);</p>
  <h2>Surface Rules</h2>
  <p>法线表面非常容易使用，但使用它们时需要遵循一些基本规则：</p>
  <ul class="colour">
    <li>首先，您应该认识到表面 (应用程序表面<i>除外</i>) 是 " 易失性的"。这意味着，如果设备或窗口失去焦点或最小化 (很好的例子是，在 Windows 上，当您按 ALT +Tab 切换到不同的窗口并再次返回时，或者在 Android 设备上，当应用程序由于调用而失去焦点时)，则表面 <strong> 可能会被破坏 </strong>。这是因为它 <em> 仅 </em> 存储在纹理内存 (<a class="tooltip" title="VRAM是视频可用的内存量，即：可以存储纹理和图像的内存空间。">VRAM</a>) 中，并且当目标平台需要该内存用于其他用途时可能会被覆盖，这意味着您应该 <i><b> 始终 </b></i> 具有某种类型的故障安全代码，通常使用 <span class="inline3_func"><a href="surface_exists.htm">surface_exists</a></span> 函数。</li>
  </ul>
  <p class="note" style="padding-top: 0.5em;padding-right: 1em;padding-bottom: 0.5em;padding-left: 4em"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note"> 注意</span></span> 对于精灵或其他视觉资源，这种情况似乎不会发生 (但实际上会发生！)，因为它们也存储在常规内存 (RAM) 中，并且当它们从纹理内存 (VRAM) 中删除时当游戏重新获得焦点时，它们会立即从常规记忆中恢复。</p>
  <ul class="colour">
    <li>其次，应注意，表面可能需要大量 VRAM 才能使用，因此应尝试将其保持尽可能小的尺寸。通常，您会尝试使它们不大于视图或显示窗口的大小。</li>
    <li>第三，您应该 <b> 仅在绘制事件中创建表面 </b>。如果您在实例的 Create 事件中创建表面，您可能会获得与 <span class="inline2"><a href="application_surface.htm">application_surface</a></span><i> 相同的 </i> 索引。这可能会导致很多问题和混乱，因为您认为您正在使用自己的表面，但实际上您正在使用当前的渲染目标。您还应该始终尝试将 <i> 绘制 </i> 限制在绘制事件中的表面，因为由于 <span data-keyref="GameMaker Name">GameMaker</span> 绘制到屏幕的优化方式，建议您保留所有绘制函数 <i> 在绘制事件内 </i>- 这包括在首次创建表面时清除表面等。在绘制事件之外绘制表面是可能的，甚至对于某些效果可能是必要的，但这不是它 <em> 应该 </em> 的方式做完了。</li>
    <li>第四，手动绘制表面时，表面 <i> 始终 </i> 位于 (0, 0) 位置。这意味着您可能需要将表面的 <em> 绝对 </em> 坐标转换为 <em> 相对 </em> 坐标。例如，如果您有一个相机大小的表面，并且希望将相机中当前可见的内容绘制到该表面，则应从实际 x 和 y 坐标中减去相机视图 x 和 y 坐标，以获得相对位置表面 (0, 0) 位置。所以，代码看起来像这样：</li>
  </ul>
  <p class="code">if (view_current == 0)<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;surface_set_target(surf);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;with (obj_Effect)<br>
    &nbsp; &nbsp; {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _vx = camera_get_view_x(view_camera[1]);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _vy = camera_get_view_y(view_camera[1]);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_sprite(sprite_index, image_index, x - _vx, y - _vy);<br>
    &nbsp; &nbsp; }<br>
    &nbsp;&nbsp;&nbsp;&nbsp;surface_reset_target();<br>
    }<br>
    else<br>
    {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;draw_surface(surf, 0, 0);<br>
    }</p>
  <ul class="colour">
    <li>最后，值得注意的是，绘制到表面将考虑每个像素的颜色<em>和</em>的Alpha分量，这两个分量既来自表面本身，也来自绘制到表面的内容。这可能会导致一些相当不直观的结果(例如，将具有0.5 Alpha的精灵绘制到具有0 Alpha的表面将给出0.25的最终Alpha)。下一页说明了这样做的原因，我们建议您在处理表面之前阅读这些原因：<a href="../../../../Additional_Information/Guide_To_Using_Blendmodes.htm">使用混合模式指南</a></li>
  </ul>
  <p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note"> 注意</span></span> 这不适用于 <a href="application_surface.htm"> 应用程序界面 </a>，仅适用于用户创建的界面。</p>
  <p>需要注意的一件事是，如果您需要将整个显示绘制到表面 (包括图块、背景等)，您可以简单地访问应用程序表面本身 (有关更多详细信息，请参阅下文)，或者您可以使用以下命令将表面分配给视口：变量 <a href="../../Cameras_And_Display/Cameras_And_Viewports/view_surface_id.htm"><span class="inline">view_surface_id[0..7]</span></a> 与此一样，该视口中的所有可见内容都将绘制到相应的表面。</p>
  <h2>Function Reference</h2>
  <p>以下函数用于处理表面(这些函数专用于创建和操作表面，但要将它们实际绘制到屏幕，应使用下面可以找到的特定绘制函数)：</p>
  <ul class="colour">
    <li><a href="surface_exists.htm">surface_exists</a></li>
    <li><a href="surface_create.htm">surface_create</a></li>
    <li><a href="surface_create_ext.htm">surface_create_ext</a></li>
    <li><a href="surface_resize.htm">surface_resize</a></li>
    <li><a href="surface_set_target.htm">surface_set_target</a></li>
    <li><a href="surface_set_target_ext.htm">surface_set_target_ext</a></li>
    <li><a href="surface_get_target.htm">surface_get_target</a></li>
    <li><a href="surface_get_target_ext.htm">surface_get_target_ext</a></li>
    <li><a href="surface_reset_target.htm">surface_reset_target</a></li>
    <li><a href="surface_copy.htm">surface_copy</a></li>
    <li><a href="surface_copy_part.htm">surface_copy_part</a></li>
    <li><a href="surface_depth_disable.htm">surface_depth_disable</a></li>
    <li><a href="surface_get_height.htm">surface_get_height</a></li>
    <li><a href="surface_get_width.htm">surface_get_width</a></li>
    <li><a href="surface_get_texture.htm">surface_get_texture</a></li>
    <li><a href="surface_get_depth_disable.htm">surface_get_depth_disable</a></li>
    <li><a href="surface_getpixel.htm">surface_getpixel</a></li>
    <li><a href="surface_getpixel_ext.htm">surface_getpixel_ext</a></li>
    <li><a href="surface_get_format.htm">surface_get_format</a></li>
    <li><a href="surface_format_is_supported.htm">surface_format_is_supported</a></li>
    <li><a href="surface_free.htm">surface_free</a></li>
    <li><a href="surface_save.htm">surface_save</a></li>
    <li><a href="surface_save_part.htm">surface_save_part</a></li>
  </ul>
  <p>绘制表面具有以下函数：</p>
  <div data-conref="../../../../assets/snippets/Note_Surface_Check_If_Exists.hts">
  <p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note"> 注意 </span></span> 在处理表面时，由于表面存储在纹理内存中，因此它们可能随时不再存在。在直接引用表面之前，您应该 <b> 始终 </b> 使用 <span class="inline3_func"><a href="surface_exists.htm">surface_exists</a></span><font face="menlo, consolas, monospace"></font> 检查表面是否存在。</p>

</div>
  <ul class="colour">
    <li><a href="draw_surface.htm">draw_surface</a></li>
    <li><a href="draw_surface_ext.htm">draw_surface_ext</a></li>
    <li><a href="draw_surface_part.htm">draw_surface_part</a></li>
    <li><a href="draw_surface_part_ext.htm">draw_surface_part_ext</a></li>
    <li><a href="draw_surface_stretched.htm">draw_surface_stretched</a></li>
    <li><a href="draw_surface_stretched_ext.htm">draw_surface_stretched_ext</a></li>
    <li><a href="draw_surface_tiled.htm">draw_surface_tiled</a></li>
    <li><a href="draw_surface_tiled_ext.htm">draw_surface_tiled_ext</a></li>
    <li><a href="draw_surface_general.htm">draw_surface_general</a></li>
  </ul>
  <p>最后，您有两个用于在<a href="../../Buffers/Buffers.htm">缓冲区</a>中存储和检索表面的函数：</p>
  <ul class="colour">
    <li><a href="../../Buffers/buffer_get_surface.htm">buffer_get_surface</a></li>
    <li><a href="../../Buffers/buffer_set_surface.htm">buffer_set_surface</a></li>
  </ul>
  <h2>Application Surface Event Order</h2>
  <p>如上所述，<span data-keyref="GameMaker Name">GameMaker</span> 实际上并不将大多数内容直接渲染到屏幕上，而是将它们渲染到 <b> 应用程序界面 </b>。这本质上是一个表面 - 就像您可以使用表面函数自己制作的任何表面一样 - 因此它可以被操纵、绘制、发送到着色器等。基本上，您通常对您创建的表面执行的任何操作都可以也可应用于应用表面。</p>
  <p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note"> 注意</span></span></b> 您对应用程序界面唯一 <b> 不能 </b> 做的就是释放它。它始终存在，尽管访问它的句柄可能会改变。</p>
  <p>When you run your game, this surface is created the first time that a <a href="../../../../The_Asset_Editors/Object_Properties/Draw_Events.htm">draw event</a> is called in each new room that you enter, which means that nothing is drawn until that point. However, you can still get the application surface position and resize it in the <b>Create Event</b> or any other event without getting any errors and the values used will be relevant to the surface when it is created. The actual sequence of events for the creation&nbsp;and drawing of the application surface is as follows:</p>
  <ul class="colour">
    <li>预绘制事件 <br>　　　--- &gt;<b> 创建应用程序界面 (如果不存在) 并设置渲染目标 </b></li>
    <li><b></b>对于每个可见视口，或者，如果没有活动视口，则执行一次 <ul class="colour"><li> 绘制开始事件 </li><li> 绘制事件 </li><li> 绘制结束事件 <br>--- &gt;<b> 应用程序表面渲染目标在此处重置 </b></li></ul></li>
    <li><b></b>绘制后事件 <br>　　　--- &gt;<b> 现在，应用程序表面默认绘制到 <a class="tooltip" title="显示缓冲区是最终绘制所有内容的“画布”。一些事件直接针对此事件（例如Pre Draw事件），而另一些事件将首先绘制到应用程序表面，然后将其绘制到显示缓冲区。"> 显示缓冲区 </a><br>　　　</b>( 不过您可以使用 <span class="inline3_func"><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></span> 将其关闭)</li>
    <li><b></b>绘制 GUI 开始事件</li>
    <li>绘制 GUI 事件</li>
    <li>绘制 GUI 结束事件</li>
  </ul>
  <p>使用此表面意味着您可以使用着色器轻松创建令人难以置信的过渡，或者将屏幕包裹在3D形状周围，或者简单地将低分辨率游戏缩放到任何分辨率屏幕...可能性是无穷的！</p>
  <p>要访问此表面，您需要使用内置全局变量 <span class="inline">application_surface</span>，该变量在以下页面中进行了说明：</p>
  <ul class="colour">
    <li><a href="application_surface.htm">application_surface</a></li>
  </ul>
  <p>&nbsp;</p>
  <p>You also have a few functions that are designed <em>only </em>for use with the application surface:</p>
  <ul class="colour">
    <li><a href="application_surface_enable.htm">application_surface_enable</a></li>
    <li><a href="application_surface_is_enabled.htm">application_surface_is_enabled</a></li>
    <li><a href="application_get_position.htm">application_get_position</a></li>
    <li><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></li>
  </ul>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="../Drawing.htm">绘制</a></div>
        <div style="float:right">Next: <a href="../Lighting/Lighting.htm">光照</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Surfaces
app surface
application surface
-->
  <!-- TAGS
surfaces_functions
-->

</body></html>